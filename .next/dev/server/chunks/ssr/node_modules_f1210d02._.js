module.exports = [
"[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        if ("TURBOPACK compile-time truthy", 1) {
            if ("TURBOPACK compile-time truthy", 1) {
                module.exports = __turbopack_context__.r("[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)");
            } else //TURBOPACK unreachable
            ;
        } else //TURBOPACK unreachable
        ;
    }
} //# sourceMappingURL=module.compiled.js.map
}),
"[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-dev-runtime.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)").vendored['react-ssr'].ReactJsxDevRuntime; //# sourceMappingURL=react-jsx-dev-runtime.js.map
}),
"[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)").vendored['react-ssr'].React; //# sourceMappingURL=react.js.map
}),
"[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
exports._ = _interop_require_default;
}),
"[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "warnOnce", {
    enumerable: true,
    get: function() {
        return warnOnce;
    }
});
let warnOnce = (_)=>{};
if ("TURBOPACK compile-time truthy", 1) {
    const warnings = new Set();
    warnOnce = (msg)=>{
        if (!warnings.has(msg)) {
            console.warn(msg);
        }
        warnings.add(msg);
    };
} //# sourceMappingURL=warn-once.js.map
}),
"[project]/node_modules/next/dist/shared/lib/image-blur-svg.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * A shared function, used on both client and server, to generate a SVG blur placeholder.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getImageBlurSvg", {
    enumerable: true,
    get: function() {
        return getImageBlurSvg;
    }
});
function getImageBlurSvg({ widthInt, heightInt, blurWidth, blurHeight, blurDataURL, objectFit }) {
    const std = 20;
    const svgWidth = blurWidth ? blurWidth * 40 : widthInt;
    const svgHeight = blurHeight ? blurHeight * 40 : heightInt;
    const viewBox = svgWidth && svgHeight ? `viewBox='0 0 ${svgWidth} ${svgHeight}'` : '';
    const preserveAspectRatio = viewBox ? 'none' : objectFit === 'contain' ? 'xMidYMid' : objectFit === 'cover' ? 'xMidYMid slice' : 'none';
    return `%3Csvg xmlns='http://www.w3.org/2000/svg' ${viewBox}%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='${std}'/%3E%3CfeColorMatrix values='1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 100 -1' result='s'/%3E%3CfeFlood x='0' y='0' width='100%25' height='100%25'/%3E%3CfeComposite operator='out' in='s'/%3E%3CfeComposite in2='SourceGraphic'/%3E%3CfeGaussianBlur stdDeviation='${std}'/%3E%3C/filter%3E%3Cimage width='100%25' height='100%25' x='0' y='0' preserveAspectRatio='${preserveAspectRatio}' style='filter: url(%23b);' href='${blurDataURL}'/%3E%3C/svg%3E`;
} //# sourceMappingURL=image-blur-svg.js.map
}),
"[project]/node_modules/next/dist/shared/lib/image-config.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    VALID_LOADERS: null,
    imageConfigDefault: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    VALID_LOADERS: function() {
        return VALID_LOADERS;
    },
    imageConfigDefault: function() {
        return imageConfigDefault;
    }
});
const VALID_LOADERS = [
    'default',
    'imgix',
    'cloudinary',
    'akamai',
    'custom'
];
const imageConfigDefault = {
    deviceSizes: [
        640,
        750,
        828,
        1080,
        1200,
        1920,
        2048,
        3840
    ],
    imageSizes: [
        32,
        48,
        64,
        96,
        128,
        256,
        384
    ],
    path: '/_next/image',
    loader: 'default',
    loaderFile: '',
    /**
   * @deprecated Use `remotePatterns` instead to protect your application from malicious users.
   */ domains: [],
    disableStaticImages: false,
    minimumCacheTTL: 14400,
    formats: [
        'image/webp'
    ],
    maximumRedirects: 3,
    dangerouslyAllowLocalIP: false,
    dangerouslyAllowSVG: false,
    contentSecurityPolicy: `script-src 'none'; frame-src 'none'; sandbox;`,
    contentDispositionType: 'attachment',
    localPatterns: undefined,
    remotePatterns: [],
    qualities: [
        75
    ],
    unoptimized: false
}; //# sourceMappingURL=image-config.js.map
}),
"[project]/node_modules/next/dist/shared/lib/get-img-props.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getImgProps", {
    enumerable: true,
    get: function() {
        return getImgProps;
    }
});
const _warnonce = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [app-ssr] (ecmascript)");
const _imageblursvg = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-blur-svg.js [app-ssr] (ecmascript)");
const _imageconfig = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-config.js [app-ssr] (ecmascript)");
const VALID_LOADING_VALUES = [
    'lazy',
    'eager',
    undefined
];
// Object-fit values that are not valid background-size values
const INVALID_BACKGROUND_SIZE_VALUES = [
    '-moz-initial',
    'fill',
    'none',
    'scale-down',
    undefined
];
function isStaticRequire(src) {
    return src.default !== undefined;
}
function isStaticImageData(src) {
    return src.src !== undefined;
}
function isStaticImport(src) {
    return !!src && typeof src === 'object' && (isStaticRequire(src) || isStaticImageData(src));
}
const allImgs = new Map();
let perfObserver;
function getInt(x) {
    if (typeof x === 'undefined') {
        return x;
    }
    if (typeof x === 'number') {
        return Number.isFinite(x) ? x : NaN;
    }
    if (typeof x === 'string' && /^[0-9]+$/.test(x)) {
        return parseInt(x, 10);
    }
    return NaN;
}
function getWidths({ deviceSizes, allSizes }, width, sizes) {
    if (sizes) {
        // Find all the "vw" percent sizes used in the sizes prop
        const viewportWidthRe = /(^|\s)(1?\d?\d)vw/g;
        const percentSizes = [];
        for(let match; match = viewportWidthRe.exec(sizes); match){
            percentSizes.push(parseInt(match[2]));
        }
        if (percentSizes.length) {
            const smallestRatio = Math.min(...percentSizes) * 0.01;
            return {
                widths: allSizes.filter((s)=>s >= deviceSizes[0] * smallestRatio),
                kind: 'w'
            };
        }
        return {
            widths: allSizes,
            kind: 'w'
        };
    }
    if (typeof width !== 'number') {
        return {
            widths: deviceSizes,
            kind: 'w'
        };
    }
    const widths = [
        ...new Set(// > are actually 3x in the green color, but only 1.5x in the red and
        // > blue colors. Showing a 3x resolution image in the app vs a 2x
        // > resolution image will be visually the same, though the 3x image
        // > takes significantly more data. Even true 3x resolution screens are
        // > wasteful as the human eye cannot see that level of detail without
        // > something like a magnifying glass.
        // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html
        [
            width,
            width * 2 /*, width * 3*/ 
        ].map((w)=>allSizes.find((p)=>p >= w) || allSizes[allSizes.length - 1]))
    ];
    return {
        widths,
        kind: 'x'
    };
}
function generateImgAttrs({ config, src, unoptimized, width, quality, sizes, loader }) {
    if (unoptimized) {
        return {
            src,
            srcSet: undefined,
            sizes: undefined
        };
    }
    const { widths, kind } = getWidths(config, width, sizes);
    const last = widths.length - 1;
    return {
        sizes: !sizes && kind === 'w' ? '100vw' : sizes,
        srcSet: widths.map((w, i)=>`${loader({
                config,
                src,
                quality,
                width: w
            })} ${kind === 'w' ? w : i + 1}${kind}`).join(', '),
        // It's intended to keep `src` the last attribute because React updates
        // attributes in order. If we keep `src` the first one, Safari will
        // immediately start to fetch `src`, before `sizes` and `srcSet` are even
        // updated by React. That causes multiple unnecessary requests if `srcSet`
        // and `sizes` are defined.
        // This bug cannot be reproduced in Chrome or Firefox.
        src: loader({
            config,
            src,
            quality,
            width: widths[last]
        })
    };
}
function getImgProps({ src, sizes, unoptimized = false, priority = false, preload = false, loading, className, quality, width, height, fill = false, style, overrideSrc, onLoad, onLoadingComplete, placeholder = 'empty', blurDataURL, fetchPriority, decoding = 'async', layout, objectFit, objectPosition, lazyBoundary, lazyRoot, ...rest }, _state) {
    const { imgConf, showAltText, blurComplete, defaultLoader } = _state;
    let config;
    let c = imgConf || _imageconfig.imageConfigDefault;
    if ('allSizes' in c) {
        config = c;
    } else {
        const allSizes = [
            ...c.deviceSizes,
            ...c.imageSizes
        ].sort((a, b)=>a - b);
        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);
        const qualities = c.qualities?.sort((a, b)=>a - b);
        config = {
            ...c,
            allSizes,
            deviceSizes,
            qualities
        };
    }
    if (typeof defaultLoader === 'undefined') {
        throw Object.defineProperty(new Error('images.loaderFile detected but the file is missing default export.\nRead more: https://nextjs.org/docs/messages/invalid-images-config'), "__NEXT_ERROR_CODE", {
            value: "E163",
            enumerable: false,
            configurable: true
        });
    }
    let loader = rest.loader || defaultLoader;
    // Remove property so it's not spread on <img> element
    delete rest.loader;
    delete rest.srcSet;
    // This special value indicates that the user
    // didn't define a "loader" prop or "loader" config.
    const isDefaultLoader = '__next_img_default' in loader;
    if (isDefaultLoader) {
        if (config.loader === 'custom') {
            throw Object.defineProperty(new Error(`Image with src "${src}" is missing "loader" prop.` + `\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader`), "__NEXT_ERROR_CODE", {
                value: "E252",
                enumerable: false,
                configurable: true
            });
        }
    } else {
        // The user defined a "loader" prop or config.
        // Since the config object is internal only, we
        // must not pass it to the user-defined "loader".
        const customImageLoader = loader;
        loader = (obj)=>{
            const { config: _, ...opts } = obj;
            return customImageLoader(opts);
        };
    }
    if (layout) {
        if (layout === 'fill') {
            fill = true;
        }
        const layoutToStyle = {
            intrinsic: {
                maxWidth: '100%',
                height: 'auto'
            },
            responsive: {
                width: '100%',
                height: 'auto'
            }
        };
        const layoutToSizes = {
            responsive: '100vw',
            fill: '100vw'
        };
        const layoutStyle = layoutToStyle[layout];
        if (layoutStyle) {
            style = {
                ...style,
                ...layoutStyle
            };
        }
        const layoutSizes = layoutToSizes[layout];
        if (layoutSizes && !sizes) {
            sizes = layoutSizes;
        }
    }
    let staticSrc = '';
    let widthInt = getInt(width);
    let heightInt = getInt(height);
    let blurWidth;
    let blurHeight;
    if (isStaticImport(src)) {
        const staticImageData = isStaticRequire(src) ? src.default : src;
        if (!staticImageData.src) {
            throw Object.defineProperty(new Error(`An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received ${JSON.stringify(staticImageData)}`), "__NEXT_ERROR_CODE", {
                value: "E460",
                enumerable: false,
                configurable: true
            });
        }
        if (!staticImageData.height || !staticImageData.width) {
            throw Object.defineProperty(new Error(`An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received ${JSON.stringify(staticImageData)}`), "__NEXT_ERROR_CODE", {
                value: "E48",
                enumerable: false,
                configurable: true
            });
        }
        blurWidth = staticImageData.blurWidth;
        blurHeight = staticImageData.blurHeight;
        blurDataURL = blurDataURL || staticImageData.blurDataURL;
        staticSrc = staticImageData.src;
        if (!fill) {
            if (!widthInt && !heightInt) {
                widthInt = staticImageData.width;
                heightInt = staticImageData.height;
            } else if (widthInt && !heightInt) {
                const ratio = widthInt / staticImageData.width;
                heightInt = Math.round(staticImageData.height * ratio);
            } else if (!widthInt && heightInt) {
                const ratio = heightInt / staticImageData.height;
                widthInt = Math.round(staticImageData.width * ratio);
            }
        }
    }
    src = typeof src === 'string' ? src : staticSrc;
    let isLazy = !priority && !preload && (loading === 'lazy' || typeof loading === 'undefined');
    if (!src || src.startsWith('data:') || src.startsWith('blob:')) {
        // https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URIs
        unoptimized = true;
        isLazy = false;
    }
    if (config.unoptimized) {
        unoptimized = true;
    }
    if (isDefaultLoader && !config.dangerouslyAllowSVG && src.split('?', 1)[0].endsWith('.svg')) {
        // Special case to make svg serve as-is to avoid proxying
        // through the built-in Image Optimization API.
        unoptimized = true;
    }
    const qualityInt = getInt(quality);
    if ("TURBOPACK compile-time truthy", 1) {
        if (config.output === 'export' && isDefaultLoader && !unoptimized) {
            throw Object.defineProperty(new Error(`Image Optimization using the default loader is not compatible with \`{ output: 'export' }\`.
  Possible solutions:
    - Remove \`{ output: 'export' }\` and run "next start" to run server mode including the Image Optimization API.
    - Configure \`{ images: { unoptimized: true } }\` in \`next.config.js\` to disable the Image Optimization API.
  Read more: https://nextjs.org/docs/messages/export-image-api`), "__NEXT_ERROR_CODE", {
                value: "E500",
                enumerable: false,
                configurable: true
            });
        }
        if (!src) {
            // React doesn't show the stack trace and there's
            // no `src` to help identify which image, so we
            // instead console.error(ref) during mount.
            unoptimized = true;
        } else {
            if (fill) {
                if (width) {
                    throw Object.defineProperty(new Error(`Image with src "${src}" has both "width" and "fill" properties. Only one should be used.`), "__NEXT_ERROR_CODE", {
                        value: "E96",
                        enumerable: false,
                        configurable: true
                    });
                }
                if (height) {
                    throw Object.defineProperty(new Error(`Image with src "${src}" has both "height" and "fill" properties. Only one should be used.`), "__NEXT_ERROR_CODE", {
                        value: "E115",
                        enumerable: false,
                        configurable: true
                    });
                }
                if (style?.position && style.position !== 'absolute') {
                    throw Object.defineProperty(new Error(`Image with src "${src}" has both "fill" and "style.position" properties. Images with "fill" always use position absolute - it cannot be modified.`), "__NEXT_ERROR_CODE", {
                        value: "E216",
                        enumerable: false,
                        configurable: true
                    });
                }
                if (style?.width && style.width !== '100%') {
                    throw Object.defineProperty(new Error(`Image with src "${src}" has both "fill" and "style.width" properties. Images with "fill" always use width 100% - it cannot be modified.`), "__NEXT_ERROR_CODE", {
                        value: "E73",
                        enumerable: false,
                        configurable: true
                    });
                }
                if (style?.height && style.height !== '100%') {
                    throw Object.defineProperty(new Error(`Image with src "${src}" has both "fill" and "style.height" properties. Images with "fill" always use height 100% - it cannot be modified.`), "__NEXT_ERROR_CODE", {
                        value: "E404",
                        enumerable: false,
                        configurable: true
                    });
                }
            } else {
                if (typeof widthInt === 'undefined') {
                    throw Object.defineProperty(new Error(`Image with src "${src}" is missing required "width" property.`), "__NEXT_ERROR_CODE", {
                        value: "E451",
                        enumerable: false,
                        configurable: true
                    });
                } else if (isNaN(widthInt)) {
                    throw Object.defineProperty(new Error(`Image with src "${src}" has invalid "width" property. Expected a numeric value in pixels but received "${width}".`), "__NEXT_ERROR_CODE", {
                        value: "E66",
                        enumerable: false,
                        configurable: true
                    });
                }
                if (typeof heightInt === 'undefined') {
                    throw Object.defineProperty(new Error(`Image with src "${src}" is missing required "height" property.`), "__NEXT_ERROR_CODE", {
                        value: "E397",
                        enumerable: false,
                        configurable: true
                    });
                } else if (isNaN(heightInt)) {
                    throw Object.defineProperty(new Error(`Image with src "${src}" has invalid "height" property. Expected a numeric value in pixels but received "${height}".`), "__NEXT_ERROR_CODE", {
                        value: "E444",
                        enumerable: false,
                        configurable: true
                    });
                }
                // eslint-disable-next-line no-control-regex
                if (/^[\x00-\x20]/.test(src)) {
                    throw Object.defineProperty(new Error(`Image with src "${src}" cannot start with a space or control character. Use src.trimStart() to remove it or encodeURIComponent(src) to keep it.`), "__NEXT_ERROR_CODE", {
                        value: "E176",
                        enumerable: false,
                        configurable: true
                    });
                }
                // eslint-disable-next-line no-control-regex
                if (/[\x00-\x20]$/.test(src)) {
                    throw Object.defineProperty(new Error(`Image with src "${src}" cannot end with a space or control character. Use src.trimEnd() to remove it or encodeURIComponent(src) to keep it.`), "__NEXT_ERROR_CODE", {
                        value: "E21",
                        enumerable: false,
                        configurable: true
                    });
                }
            }
        }
        if (!VALID_LOADING_VALUES.includes(loading)) {
            throw Object.defineProperty(new Error(`Image with src "${src}" has invalid "loading" property. Provided "${loading}" should be one of ${VALID_LOADING_VALUES.map(String).join(',')}.`), "__NEXT_ERROR_CODE", {
                value: "E357",
                enumerable: false,
                configurable: true
            });
        }
        if (priority && loading === 'lazy') {
            throw Object.defineProperty(new Error(`Image with src "${src}" has both "priority" and "loading='lazy'" properties. Only one should be used.`), "__NEXT_ERROR_CODE", {
                value: "E218",
                enumerable: false,
                configurable: true
            });
        }
        if (preload && loading === 'lazy') {
            throw Object.defineProperty(new Error(`Image with src "${src}" has both "preload" and "loading='lazy'" properties. Only one should be used.`), "__NEXT_ERROR_CODE", {
                value: "E803",
                enumerable: false,
                configurable: true
            });
        }
        if (preload && priority) {
            throw Object.defineProperty(new Error(`Image with src "${src}" has both "preload" and "priority" properties. Only "preload" should be used.`), "__NEXT_ERROR_CODE", {
                value: "E802",
                enumerable: false,
                configurable: true
            });
        }
        if (placeholder !== 'empty' && placeholder !== 'blur' && !placeholder.startsWith('data:image/')) {
            throw Object.defineProperty(new Error(`Image with src "${src}" has invalid "placeholder" property "${placeholder}".`), "__NEXT_ERROR_CODE", {
                value: "E431",
                enumerable: false,
                configurable: true
            });
        }
        if (placeholder !== 'empty') {
            if (widthInt && heightInt && widthInt * heightInt < 1600) {
                (0, _warnonce.warnOnce)(`Image with src "${src}" is smaller than 40x40. Consider removing the "placeholder" property to improve performance.`);
            }
        }
        if (qualityInt && config.qualities && !config.qualities.includes(qualityInt)) {
            (0, _warnonce.warnOnce)(`Image with src "${src}" is using quality "${qualityInt}" which is not configured in images.qualities [${config.qualities.join(', ')}]. Please update your config to [${[
                ...config.qualities,
                qualityInt
            ].sort().join(', ')}].` + `\nRead more: https://nextjs.org/docs/messages/next-image-unconfigured-qualities`);
        }
        if (placeholder === 'blur' && !blurDataURL) {
            const VALID_BLUR_EXT = [
                'jpeg',
                'png',
                'webp',
                'avif'
            ] // should match next-image-loader
            ;
            throw Object.defineProperty(new Error(`Image with src "${src}" has "placeholder='blur'" property but is missing the "blurDataURL" property.
        Possible solutions:
          - Add a "blurDataURL" property, the contents should be a small Data URL to represent the image
          - Change the "src" property to a static import with one of the supported file types: ${VALID_BLUR_EXT.join(',')} (animated images not supported)
          - Remove the "placeholder" property, effectively no blur effect
        Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url`), "__NEXT_ERROR_CODE", {
                value: "E371",
                enumerable: false,
                configurable: true
            });
        }
        if ('ref' in rest) {
            (0, _warnonce.warnOnce)(`Image with src "${src}" is using unsupported "ref" property. Consider using the "onLoad" property instead.`);
        }
        if (!unoptimized && !isDefaultLoader) {
            const urlStr = loader({
                config,
                src,
                width: widthInt || 400,
                quality: qualityInt || 75
            });
            let url;
            try {
                url = new URL(urlStr);
            } catch (err) {}
            if (urlStr === src || url && url.pathname === src && !url.search) {
                (0, _warnonce.warnOnce)(`Image with src "${src}" has a "loader" property that does not implement width. Please implement it or use the "unoptimized" property instead.` + `\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width`);
            }
        }
        if (onLoadingComplete) {
            (0, _warnonce.warnOnce)(`Image with src "${src}" is using deprecated "onLoadingComplete" property. Please use the "onLoad" property instead.`);
        }
        for (const [legacyKey, legacyValue] of Object.entries({
            layout,
            objectFit,
            objectPosition,
            lazyBoundary,
            lazyRoot
        })){
            if (legacyValue) {
                (0, _warnonce.warnOnce)(`Image with src "${src}" has legacy prop "${legacyKey}". Did you forget to run the codemod?` + `\nRead more: https://nextjs.org/docs/messages/next-image-upgrade-to-13`);
            }
        }
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
    }
    const imgStyle = Object.assign(fill ? {
        position: 'absolute',
        height: '100%',
        width: '100%',
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        objectFit,
        objectPosition
    } : {}, showAltText ? {} : {
        color: 'transparent'
    }, style);
    const backgroundImage = !blurComplete && placeholder !== 'empty' ? placeholder === 'blur' ? `url("data:image/svg+xml;charset=utf-8,${(0, _imageblursvg.getImageBlurSvg)({
        widthInt,
        heightInt,
        blurWidth,
        blurHeight,
        blurDataURL: blurDataURL || '',
        objectFit: imgStyle.objectFit
    })}")` : `url("${placeholder}")` // assume `data:image/`
     : null;
    const backgroundSize = !INVALID_BACKGROUND_SIZE_VALUES.includes(imgStyle.objectFit) ? imgStyle.objectFit : imgStyle.objectFit === 'fill' ? '100% 100%' // the background-size equivalent of `fill`
     : 'cover';
    let placeholderStyle = backgroundImage ? {
        backgroundSize,
        backgroundPosition: imgStyle.objectPosition || '50% 50%',
        backgroundRepeat: 'no-repeat',
        backgroundImage
    } : {};
    if ("TURBOPACK compile-time truthy", 1) {
        if (placeholderStyle.backgroundImage && placeholder === 'blur' && blurDataURL?.startsWith('/')) {
            // During `next dev`, we don't want to generate blur placeholders with webpack
            // because it can delay starting the dev server. Instead, `next-image-loader.js`
            // will inline a special url to lazily generate the blur placeholder at request time.
            placeholderStyle.backgroundImage = `url("${blurDataURL}")`;
        }
    }
    const imgAttributes = generateImgAttrs({
        config,
        src,
        unoptimized,
        width: widthInt,
        quality: qualityInt,
        sizes,
        loader
    });
    const loadingFinal = isLazy ? 'lazy' : loading;
    if ("TURBOPACK compile-time truthy", 1) {
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
    }
    const props = {
        ...rest,
        loading: loadingFinal,
        fetchPriority,
        width: widthInt,
        height: heightInt,
        decoding,
        className,
        style: {
            ...imgStyle,
            ...placeholderStyle
        },
        sizes: imgAttributes.sizes,
        srcSet: imgAttributes.srcSet,
        src: overrideSrc || imgAttributes.src
    };
    const meta = {
        unoptimized,
        preload: preload || priority,
        placeholder,
        fill
    };
    return {
        props,
        meta
    };
} //# sourceMappingURL=get-img-props.js.map
}),
"[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) return obj;
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") return {
        default: obj
    };
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) Object.defineProperty(newObj, key, desc);
            else newObj[key] = obj[key];
        }
    }
    newObj.default = obj;
    if (cache) cache.set(obj, newObj);
    return newObj;
}
exports._ = _interop_require_wildcard;
}),
"[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)").vendored['react-ssr'].ReactJsxRuntime; //# sourceMappingURL=react-jsx-runtime.js.map
}),
"[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)").vendored['react-ssr'].ReactDOM; //# sourceMappingURL=react-dom.js.map
}),
"[project]/node_modules/next/dist/shared/lib/side-effect.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return SideEffect;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
const isServer = ("TURBOPACK compile-time value", "undefined") === 'undefined';
const useClientOnlyLayoutEffect = ("TURBOPACK compile-time truthy", 1) ? ()=>{} : "TURBOPACK unreachable";
const useClientOnlyEffect = ("TURBOPACK compile-time truthy", 1) ? ()=>{} : "TURBOPACK unreachable";
function SideEffect(props) {
    const { headManager, reduceComponentsToState } = props;
    function emitChange() {
        if (headManager && headManager.mountedInstances) {
            const headElements = _react.Children.toArray(Array.from(headManager.mountedInstances).filter(Boolean));
            headManager.updateHead(reduceComponentsToState(headElements));
        }
    }
    if ("TURBOPACK compile-time truthy", 1) {
        headManager?.mountedInstances?.add(props.children);
        emitChange();
    }
    useClientOnlyLayoutEffect(()=>{
        headManager?.mountedInstances?.add(props.children);
        return ()=>{
            headManager?.mountedInstances?.delete(props.children);
        };
    });
    // We need to call `updateHead` method whenever the `SideEffect` is trigger in all
    // life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s
    // being rendered, we only trigger the method from the last one.
    // This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`
    // singleton in the layout effect pass, and actually trigger it in the effect pass.
    useClientOnlyLayoutEffect(()=>{
        if (headManager) {
            headManager._pendingUpdate = emitChange;
        }
        return ()=>{
            if (headManager) {
                headManager._pendingUpdate = emitChange;
            }
        };
    });
    useClientOnlyEffect(()=>{
        if (headManager && headManager._pendingUpdate) {
            headManager._pendingUpdate();
            headManager._pendingUpdate = null;
        }
        return ()=>{
            if (headManager && headManager._pendingUpdate) {
                headManager._pendingUpdate();
                headManager._pendingUpdate = null;
            }
        };
    });
    return null;
} //# sourceMappingURL=side-effect.js.map
}),
"[project]/node_modules/next/dist/server/route-modules/app-page/vendored/contexts/head-manager-context.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)").vendored['contexts'].HeadManagerContext; //# sourceMappingURL=head-manager-context.js.map
}),
"[project]/node_modules/next/dist/shared/lib/head.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    default: null,
    defaultHead: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return _default;
    },
    defaultHead: function() {
        return defaultHead;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-ssr] (ecmascript)");
const _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-ssr] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"));
const _sideeffect = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/side-effect.js [app-ssr] (ecmascript)"));
const _headmanagercontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/contexts/head-manager-context.js [app-ssr] (ecmascript)");
const _warnonce = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [app-ssr] (ecmascript)");
function defaultHead() {
    const head = [
        /*#__PURE__*/ (0, _jsxruntime.jsx)("meta", {
            charSet: "utf-8"
        }, "charset"),
        /*#__PURE__*/ (0, _jsxruntime.jsx)("meta", {
            name: "viewport",
            content: "width=device-width"
        }, "viewport")
    ];
    return head;
}
function onlyReactElement(list, child) {
    // React children can be "string" or "number" in this case we ignore them for backwards compat
    if (typeof child === 'string' || typeof child === 'number') {
        return list;
    }
    // Adds support for React.Fragment
    if (child.type === _react.default.Fragment) {
        return list.concat(_react.default.Children.toArray(child.props.children).reduce((fragmentList, fragmentChild)=>{
            if (typeof fragmentChild === 'string' || typeof fragmentChild === 'number') {
                return fragmentList;
            }
            return fragmentList.concat(fragmentChild);
        }, []));
    }
    return list.concat(child);
}
const METATYPES = [
    'name',
    'httpEquiv',
    'charSet',
    'itemProp'
];
/*
 returns a function for filtering head child elements
 which shouldn't be duplicated, like <title/>
 Also adds support for deduplicated `key` properties
*/ function unique() {
    const keys = new Set();
    const tags = new Set();
    const metaTypes = new Set();
    const metaCategories = {};
    return (h)=>{
        let isUnique = true;
        let hasKey = false;
        if (h.key && typeof h.key !== 'number' && h.key.indexOf('$') > 0) {
            hasKey = true;
            const key = h.key.slice(h.key.indexOf('$') + 1);
            if (keys.has(key)) {
                isUnique = false;
            } else {
                keys.add(key);
            }
        }
        // eslint-disable-next-line default-case
        switch(h.type){
            case 'title':
            case 'base':
                if (tags.has(h.type)) {
                    isUnique = false;
                } else {
                    tags.add(h.type);
                }
                break;
            case 'meta':
                for(let i = 0, len = METATYPES.length; i < len; i++){
                    const metatype = METATYPES[i];
                    if (!h.props.hasOwnProperty(metatype)) continue;
                    if (metatype === 'charSet') {
                        if (metaTypes.has(metatype)) {
                            isUnique = false;
                        } else {
                            metaTypes.add(metatype);
                        }
                    } else {
                        const category = h.props[metatype];
                        const categories = metaCategories[metatype] || new Set();
                        if ((metatype !== 'name' || !hasKey) && categories.has(category)) {
                            isUnique = false;
                        } else {
                            categories.add(category);
                            metaCategories[metatype] = categories;
                        }
                    }
                }
                break;
        }
        return isUnique;
    };
}
/**
 *
 * @param headChildrenElements List of children of <Head>
 */ function reduceComponents(headChildrenElements) {
    return headChildrenElements.reduce(onlyReactElement, []).reverse().concat(defaultHead().reverse()).filter(unique()).reverse().map((c, i)=>{
        const key = c.key || i;
        if ("TURBOPACK compile-time truthy", 1) {
            // omit JSON-LD structured data snippets from the warning
            if (c.type === 'script' && c.props['type'] !== 'application/ld+json') {
                const srcMessage = c.props['src'] ? `<script> tag with src="${c.props['src']}"` : `inline <script>`;
                (0, _warnonce.warnOnce)(`Do not add <script> tags using next/head (see ${srcMessage}). Use next/script instead. \nSee more info here: https://nextjs.org/docs/messages/no-script-tags-in-head-component`);
            } else if (c.type === 'link' && c.props['rel'] === 'stylesheet') {
                (0, _warnonce.warnOnce)(`Do not add stylesheets using next/head (see <link rel="stylesheet"> tag with href="${c.props['href']}"). Use Document instead. \nSee more info here: https://nextjs.org/docs/messages/no-stylesheets-in-head-component`);
            }
        }
        return /*#__PURE__*/ _react.default.cloneElement(c, {
            key
        });
    });
}
/**
 * This component injects elements to `<head>` of your page.
 * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.
 */ function Head({ children }) {
    const headManager = (0, _react.useContext)(_headmanagercontextsharedruntime.HeadManagerContext);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_sideeffect.default, {
        reduceComponentsToState: reduceComponents,
        headManager: headManager,
        children: children
    });
}
const _default = Head;
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=head.js.map
}),
"[project]/node_modules/next/dist/server/route-modules/app-page/vendored/contexts/image-config-context.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)").vendored['contexts'].ImageConfigContext; //# sourceMappingURL=image-config-context.js.map
}),
"[project]/node_modules/next/dist/server/route-modules/app-page/vendored/contexts/router-context.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)").vendored['contexts'].RouterContext; //# sourceMappingURL=router-context.js.map
}),
"[project]/node_modules/next/dist/shared/lib/find-closest-quality.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "findClosestQuality", {
    enumerable: true,
    get: function() {
        return findClosestQuality;
    }
});
function findClosestQuality(quality, config) {
    const q = quality || 75;
    if (!config?.qualities?.length) {
        return q;
    }
    return config.qualities.reduce((prev, cur)=>Math.abs(cur - q) < Math.abs(prev - q) ? cur : prev, 0);
} //# sourceMappingURL=find-closest-quality.js.map
}),
"[project]/node_modules/next/dist/compiled/picomatch/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

(()=>{
    "use strict";
    var t = {
        170: (t, e, u)=>{
            const n = u(510);
            const isWindows = ()=>{
                if (typeof navigator !== "undefined" && navigator.platform) {
                    const t = navigator.platform.toLowerCase();
                    return t === "win32" || t === "windows";
                }
                if (typeof process !== "undefined" && process.platform) {
                    return process.platform === "win32";
                }
                return false;
            };
            function picomatch(t, e, u = false) {
                if (e && (e.windows === null || e.windows === undefined)) {
                    e = {
                        ...e,
                        windows: isWindows()
                    };
                }
                return n(t, e, u);
            }
            Object.assign(picomatch, n);
            t.exports = picomatch;
        },
        154: (t)=>{
            const e = "\\\\/";
            const u = `[^${e}]`;
            const n = "\\.";
            const o = "\\+";
            const s = "\\?";
            const r = "\\/";
            const a = "(?=.)";
            const i = "[^/]";
            const c = `(?:${r}|$)`;
            const p = `(?:^|${r})`;
            const l = `${n}{1,2}${c}`;
            const f = `(?!${n})`;
            const A = `(?!${p}${l})`;
            const _ = `(?!${n}{0,1}${c})`;
            const R = `(?!${l})`;
            const E = `[^.${r}]`;
            const h = `${i}*?`;
            const g = "/";
            const b = {
                DOT_LITERAL: n,
                PLUS_LITERAL: o,
                QMARK_LITERAL: s,
                SLASH_LITERAL: r,
                ONE_CHAR: a,
                QMARK: i,
                END_ANCHOR: c,
                DOTS_SLASH: l,
                NO_DOT: f,
                NO_DOTS: A,
                NO_DOT_SLASH: _,
                NO_DOTS_SLASH: R,
                QMARK_NO_DOT: E,
                STAR: h,
                START_ANCHOR: p,
                SEP: g
            };
            const C = {
                ...b,
                SLASH_LITERAL: `[${e}]`,
                QMARK: u,
                STAR: `${u}*?`,
                DOTS_SLASH: `${n}{1,2}(?:[${e}]|$)`,
                NO_DOT: `(?!${n})`,
                NO_DOTS: `(?!(?:^|[${e}])${n}{1,2}(?:[${e}]|$))`,
                NO_DOT_SLASH: `(?!${n}{0,1}(?:[${e}]|$))`,
                NO_DOTS_SLASH: `(?!${n}{1,2}(?:[${e}]|$))`,
                QMARK_NO_DOT: `[^.${e}]`,
                START_ANCHOR: `(?:^|[${e}])`,
                END_ANCHOR: `(?:[${e}]|$)`,
                SEP: "\\"
            };
            const y = {
                alnum: "a-zA-Z0-9",
                alpha: "a-zA-Z",
                ascii: "\\x00-\\x7F",
                blank: " \\t",
                cntrl: "\\x00-\\x1F\\x7F",
                digit: "0-9",
                graph: "\\x21-\\x7E",
                lower: "a-z",
                print: "\\x20-\\x7E ",
                punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
                space: " \\t\\r\\n\\v\\f",
                upper: "A-Z",
                word: "A-Za-z0-9_",
                xdigit: "A-Fa-f0-9"
            };
            t.exports = {
                MAX_LENGTH: 1024 * 64,
                POSIX_REGEX_SOURCE: y,
                REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
                REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
                REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
                REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
                REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
                REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
                REPLACEMENTS: {
                    "***": "*",
                    "**/**": "**",
                    "**/**/**": "**"
                },
                CHAR_0: 48,
                CHAR_9: 57,
                CHAR_UPPERCASE_A: 65,
                CHAR_LOWERCASE_A: 97,
                CHAR_UPPERCASE_Z: 90,
                CHAR_LOWERCASE_Z: 122,
                CHAR_LEFT_PARENTHESES: 40,
                CHAR_RIGHT_PARENTHESES: 41,
                CHAR_ASTERISK: 42,
                CHAR_AMPERSAND: 38,
                CHAR_AT: 64,
                CHAR_BACKWARD_SLASH: 92,
                CHAR_CARRIAGE_RETURN: 13,
                CHAR_CIRCUMFLEX_ACCENT: 94,
                CHAR_COLON: 58,
                CHAR_COMMA: 44,
                CHAR_DOT: 46,
                CHAR_DOUBLE_QUOTE: 34,
                CHAR_EQUAL: 61,
                CHAR_EXCLAMATION_MARK: 33,
                CHAR_FORM_FEED: 12,
                CHAR_FORWARD_SLASH: 47,
                CHAR_GRAVE_ACCENT: 96,
                CHAR_HASH: 35,
                CHAR_HYPHEN_MINUS: 45,
                CHAR_LEFT_ANGLE_BRACKET: 60,
                CHAR_LEFT_CURLY_BRACE: 123,
                CHAR_LEFT_SQUARE_BRACKET: 91,
                CHAR_LINE_FEED: 10,
                CHAR_NO_BREAK_SPACE: 160,
                CHAR_PERCENT: 37,
                CHAR_PLUS: 43,
                CHAR_QUESTION_MARK: 63,
                CHAR_RIGHT_ANGLE_BRACKET: 62,
                CHAR_RIGHT_CURLY_BRACE: 125,
                CHAR_RIGHT_SQUARE_BRACKET: 93,
                CHAR_SEMICOLON: 59,
                CHAR_SINGLE_QUOTE: 39,
                CHAR_SPACE: 32,
                CHAR_TAB: 9,
                CHAR_UNDERSCORE: 95,
                CHAR_VERTICAL_LINE: 124,
                CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
                extglobChars (t) {
                    return {
                        "!": {
                            type: "negate",
                            open: "(?:(?!(?:",
                            close: `))${t.STAR})`
                        },
                        "?": {
                            type: "qmark",
                            open: "(?:",
                            close: ")?"
                        },
                        "+": {
                            type: "plus",
                            open: "(?:",
                            close: ")+"
                        },
                        "*": {
                            type: "star",
                            open: "(?:",
                            close: ")*"
                        },
                        "@": {
                            type: "at",
                            open: "(?:",
                            close: ")"
                        }
                    };
                },
                globChars (t) {
                    return t === true ? C : b;
                }
            };
        },
        697: (t, e, u)=>{
            const n = u(154);
            const o = u(96);
            const { MAX_LENGTH: s, POSIX_REGEX_SOURCE: r, REGEX_NON_SPECIAL_CHARS: a, REGEX_SPECIAL_CHARS_BACKREF: i, REPLACEMENTS: c } = n;
            const expandRange = (t, e)=>{
                if (typeof e.expandRange === "function") {
                    return e.expandRange(...t, e);
                }
                t.sort();
                const u = `[${t.join("-")}]`;
                try {
                    new RegExp(u);
                } catch (e) {
                    return t.map((t)=>o.escapeRegex(t)).join("..");
                }
                return u;
            };
            const syntaxError = (t, e)=>`Missing ${t}: "${e}" - use "\\\\${e}" to match literal characters`;
            const parse = (t, e)=>{
                if (typeof t !== "string") {
                    throw new TypeError("Expected a string");
                }
                t = c[t] || t;
                const u = {
                    ...e
                };
                const p = typeof u.maxLength === "number" ? Math.min(s, u.maxLength) : s;
                let l = t.length;
                if (l > p) {
                    throw new SyntaxError(`Input length: ${l}, exceeds maximum allowed length: ${p}`);
                }
                const f = {
                    type: "bos",
                    value: "",
                    output: u.prepend || ""
                };
                const A = [
                    f
                ];
                const _ = u.capture ? "" : "?:";
                const R = n.globChars(u.windows);
                const E = n.extglobChars(R);
                const { DOT_LITERAL: h, PLUS_LITERAL: g, SLASH_LITERAL: b, ONE_CHAR: C, DOTS_SLASH: y, NO_DOT: $, NO_DOT_SLASH: x, NO_DOTS_SLASH: S, QMARK: H, QMARK_NO_DOT: v, STAR: d, START_ANCHOR: L } = R;
                const globstar = (t)=>`(${_}(?:(?!${L}${t.dot ? y : h}).)*?)`;
                const T = u.dot ? "" : $;
                const O = u.dot ? H : v;
                let k = u.bash === true ? globstar(u) : d;
                if (u.capture) {
                    k = `(${k})`;
                }
                if (typeof u.noext === "boolean") {
                    u.noextglob = u.noext;
                }
                const m = {
                    input: t,
                    index: -1,
                    start: 0,
                    dot: u.dot === true,
                    consumed: "",
                    output: "",
                    prefix: "",
                    backtrack: false,
                    negated: false,
                    brackets: 0,
                    braces: 0,
                    parens: 0,
                    quotes: 0,
                    globstar: false,
                    tokens: A
                };
                t = o.removePrefix(t, m);
                l = t.length;
                const w = [];
                const N = [];
                const I = [];
                let B = f;
                let G;
                const eos = ()=>m.index === l - 1;
                const D = m.peek = (e = 1)=>t[m.index + e];
                const M = m.advance = ()=>t[++m.index] || "";
                const remaining = ()=>t.slice(m.index + 1);
                const consume = (t = "", e = 0)=>{
                    m.consumed += t;
                    m.index += e;
                };
                const append = (t)=>{
                    m.output += t.output != null ? t.output : t.value;
                    consume(t.value);
                };
                const negate = ()=>{
                    let t = 1;
                    while(D() === "!" && (D(2) !== "(" || D(3) === "?")){
                        M();
                        m.start++;
                        t++;
                    }
                    if (t % 2 === 0) {
                        return false;
                    }
                    m.negated = true;
                    m.start++;
                    return true;
                };
                const increment = (t)=>{
                    m[t]++;
                    I.push(t);
                };
                const decrement = (t)=>{
                    m[t]--;
                    I.pop();
                };
                const push = (t)=>{
                    if (B.type === "globstar") {
                        const e = m.braces > 0 && (t.type === "comma" || t.type === "brace");
                        const u = t.extglob === true || w.length && (t.type === "pipe" || t.type === "paren");
                        if (t.type !== "slash" && t.type !== "paren" && !e && !u) {
                            m.output = m.output.slice(0, -B.output.length);
                            B.type = "star";
                            B.value = "*";
                            B.output = k;
                            m.output += B.output;
                        }
                    }
                    if (w.length && t.type !== "paren") {
                        w[w.length - 1].inner += t.value;
                    }
                    if (t.value || t.output) append(t);
                    if (B && B.type === "text" && t.type === "text") {
                        B.output = (B.output || B.value) + t.value;
                        B.value += t.value;
                        return;
                    }
                    t.prev = B;
                    A.push(t);
                    B = t;
                };
                const extglobOpen = (t, e)=>{
                    const n = {
                        ...E[e],
                        conditions: 1,
                        inner: ""
                    };
                    n.prev = B;
                    n.parens = m.parens;
                    n.output = m.output;
                    const o = (u.capture ? "(" : "") + n.open;
                    increment("parens");
                    push({
                        type: t,
                        value: e,
                        output: m.output ? "" : C
                    });
                    push({
                        type: "paren",
                        extglob: true,
                        value: M(),
                        output: o
                    });
                    w.push(n);
                };
                const extglobClose = (t)=>{
                    let n = t.close + (u.capture ? ")" : "");
                    let o;
                    if (t.type === "negate") {
                        let s = k;
                        if (t.inner && t.inner.length > 1 && t.inner.includes("/")) {
                            s = globstar(u);
                        }
                        if (s !== k || eos() || /^\)+$/.test(remaining())) {
                            n = t.close = `)$))${s}`;
                        }
                        if (t.inner.includes("*") && (o = remaining()) && /^\.[^\\/.]+$/.test(o)) {
                            const u = parse(o, {
                                ...e,
                                fastpaths: false
                            }).output;
                            n = t.close = `)${u})${s})`;
                        }
                        if (t.prev.type === "bos") {
                            m.negatedExtglob = true;
                        }
                    }
                    push({
                        type: "paren",
                        extglob: true,
                        value: G,
                        output: n
                    });
                    decrement("parens");
                };
                if (u.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(t)) {
                    let n = false;
                    let s = t.replace(i, (t, e, u, o, s, r)=>{
                        if (o === "\\") {
                            n = true;
                            return t;
                        }
                        if (o === "?") {
                            if (e) {
                                return e + o + (s ? H.repeat(s.length) : "");
                            }
                            if (r === 0) {
                                return O + (s ? H.repeat(s.length) : "");
                            }
                            return H.repeat(u.length);
                        }
                        if (o === ".") {
                            return h.repeat(u.length);
                        }
                        if (o === "*") {
                            if (e) {
                                return e + o + (s ? k : "");
                            }
                            return k;
                        }
                        return e ? t : `\\${t}`;
                    });
                    if (n === true) {
                        if (u.unescape === true) {
                            s = s.replace(/\\/g, "");
                        } else {
                            s = s.replace(/\\+/g, (t)=>t.length % 2 === 0 ? "\\\\" : t ? "\\" : "");
                        }
                    }
                    if (s === t && u.contains === true) {
                        m.output = t;
                        return m;
                    }
                    m.output = o.wrapOutput(s, m, e);
                    return m;
                }
                while(!eos()){
                    G = M();
                    if (G === "\0") {
                        continue;
                    }
                    if (G === "\\") {
                        const t = D();
                        if (t === "/" && u.bash !== true) {
                            continue;
                        }
                        if (t === "." || t === ";") {
                            continue;
                        }
                        if (!t) {
                            G += "\\";
                            push({
                                type: "text",
                                value: G
                            });
                            continue;
                        }
                        const e = /^\\+/.exec(remaining());
                        let n = 0;
                        if (e && e[0].length > 2) {
                            n = e[0].length;
                            m.index += n;
                            if (n % 2 !== 0) {
                                G += "\\";
                            }
                        }
                        if (u.unescape === true) {
                            G = M();
                        } else {
                            G += M();
                        }
                        if (m.brackets === 0) {
                            push({
                                type: "text",
                                value: G
                            });
                            continue;
                        }
                    }
                    if (m.brackets > 0 && (G !== "]" || B.value === "[" || B.value === "[^")) {
                        if (u.posix !== false && G === ":") {
                            const t = B.value.slice(1);
                            if (t.includes("[")) {
                                B.posix = true;
                                if (t.includes(":")) {
                                    const t = B.value.lastIndexOf("[");
                                    const e = B.value.slice(0, t);
                                    const u = B.value.slice(t + 2);
                                    const n = r[u];
                                    if (n) {
                                        B.value = e + n;
                                        m.backtrack = true;
                                        M();
                                        if (!f.output && A.indexOf(B) === 1) {
                                            f.output = C;
                                        }
                                        continue;
                                    }
                                }
                            }
                        }
                        if (G === "[" && D() !== ":" || G === "-" && D() === "]") {
                            G = `\\${G}`;
                        }
                        if (G === "]" && (B.value === "[" || B.value === "[^")) {
                            G = `\\${G}`;
                        }
                        if (u.posix === true && G === "!" && B.value === "[") {
                            G = "^";
                        }
                        B.value += G;
                        append({
                            value: G
                        });
                        continue;
                    }
                    if (m.quotes === 1 && G !== '"') {
                        G = o.escapeRegex(G);
                        B.value += G;
                        append({
                            value: G
                        });
                        continue;
                    }
                    if (G === '"') {
                        m.quotes = m.quotes === 1 ? 0 : 1;
                        if (u.keepQuotes === true) {
                            push({
                                type: "text",
                                value: G
                            });
                        }
                        continue;
                    }
                    if (G === "(") {
                        increment("parens");
                        push({
                            type: "paren",
                            value: G
                        });
                        continue;
                    }
                    if (G === ")") {
                        if (m.parens === 0 && u.strictBrackets === true) {
                            throw new SyntaxError(syntaxError("opening", "("));
                        }
                        const t = w[w.length - 1];
                        if (t && m.parens === t.parens + 1) {
                            extglobClose(w.pop());
                            continue;
                        }
                        push({
                            type: "paren",
                            value: G,
                            output: m.parens ? ")" : "\\)"
                        });
                        decrement("parens");
                        continue;
                    }
                    if (G === "[") {
                        if (u.nobracket === true || !remaining().includes("]")) {
                            if (u.nobracket !== true && u.strictBrackets === true) {
                                throw new SyntaxError(syntaxError("closing", "]"));
                            }
                            G = `\\${G}`;
                        } else {
                            increment("brackets");
                        }
                        push({
                            type: "bracket",
                            value: G
                        });
                        continue;
                    }
                    if (G === "]") {
                        if (u.nobracket === true || B && B.type === "bracket" && B.value.length === 1) {
                            push({
                                type: "text",
                                value: G,
                                output: `\\${G}`
                            });
                            continue;
                        }
                        if (m.brackets === 0) {
                            if (u.strictBrackets === true) {
                                throw new SyntaxError(syntaxError("opening", "["));
                            }
                            push({
                                type: "text",
                                value: G,
                                output: `\\${G}`
                            });
                            continue;
                        }
                        decrement("brackets");
                        const t = B.value.slice(1);
                        if (B.posix !== true && t[0] === "^" && !t.includes("/")) {
                            G = `/${G}`;
                        }
                        B.value += G;
                        append({
                            value: G
                        });
                        if (u.literalBrackets === false || o.hasRegexChars(t)) {
                            continue;
                        }
                        const e = o.escapeRegex(B.value);
                        m.output = m.output.slice(0, -B.value.length);
                        if (u.literalBrackets === true) {
                            m.output += e;
                            B.value = e;
                            continue;
                        }
                        B.value = `(${_}${e}|${B.value})`;
                        m.output += B.value;
                        continue;
                    }
                    if (G === "{" && u.nobrace !== true) {
                        increment("braces");
                        const t = {
                            type: "brace",
                            value: G,
                            output: "(",
                            outputIndex: m.output.length,
                            tokensIndex: m.tokens.length
                        };
                        N.push(t);
                        push(t);
                        continue;
                    }
                    if (G === "}") {
                        const t = N[N.length - 1];
                        if (u.nobrace === true || !t) {
                            push({
                                type: "text",
                                value: G,
                                output: G
                            });
                            continue;
                        }
                        let e = ")";
                        if (t.dots === true) {
                            const t = A.slice();
                            const n = [];
                            for(let e = t.length - 1; e >= 0; e--){
                                A.pop();
                                if (t[e].type === "brace") {
                                    break;
                                }
                                if (t[e].type !== "dots") {
                                    n.unshift(t[e].value);
                                }
                            }
                            e = expandRange(n, u);
                            m.backtrack = true;
                        }
                        if (t.comma !== true && t.dots !== true) {
                            const u = m.output.slice(0, t.outputIndex);
                            const n = m.tokens.slice(t.tokensIndex);
                            t.value = t.output = "\\{";
                            G = e = "\\}";
                            m.output = u;
                            for (const t of n){
                                m.output += t.output || t.value;
                            }
                        }
                        push({
                            type: "brace",
                            value: G,
                            output: e
                        });
                        decrement("braces");
                        N.pop();
                        continue;
                    }
                    if (G === "|") {
                        if (w.length > 0) {
                            w[w.length - 1].conditions++;
                        }
                        push({
                            type: "text",
                            value: G
                        });
                        continue;
                    }
                    if (G === ",") {
                        let t = G;
                        const e = N[N.length - 1];
                        if (e && I[I.length - 1] === "braces") {
                            e.comma = true;
                            t = "|";
                        }
                        push({
                            type: "comma",
                            value: G,
                            output: t
                        });
                        continue;
                    }
                    if (G === "/") {
                        if (B.type === "dot" && m.index === m.start + 1) {
                            m.start = m.index + 1;
                            m.consumed = "";
                            m.output = "";
                            A.pop();
                            B = f;
                            continue;
                        }
                        push({
                            type: "slash",
                            value: G,
                            output: b
                        });
                        continue;
                    }
                    if (G === ".") {
                        if (m.braces > 0 && B.type === "dot") {
                            if (B.value === ".") B.output = h;
                            const t = N[N.length - 1];
                            B.type = "dots";
                            B.output += G;
                            B.value += G;
                            t.dots = true;
                            continue;
                        }
                        if (m.braces + m.parens === 0 && B.type !== "bos" && B.type !== "slash") {
                            push({
                                type: "text",
                                value: G,
                                output: h
                            });
                            continue;
                        }
                        push({
                            type: "dot",
                            value: G,
                            output: h
                        });
                        continue;
                    }
                    if (G === "?") {
                        const t = B && B.value === "(";
                        if (!t && u.noextglob !== true && D() === "(" && D(2) !== "?") {
                            extglobOpen("qmark", G);
                            continue;
                        }
                        if (B && B.type === "paren") {
                            const t = D();
                            let e = G;
                            if (B.value === "(" && !/[!=<:]/.test(t) || t === "<" && !/<([!=]|\w+>)/.test(remaining())) {
                                e = `\\${G}`;
                            }
                            push({
                                type: "text",
                                value: G,
                                output: e
                            });
                            continue;
                        }
                        if (u.dot !== true && (B.type === "slash" || B.type === "bos")) {
                            push({
                                type: "qmark",
                                value: G,
                                output: v
                            });
                            continue;
                        }
                        push({
                            type: "qmark",
                            value: G,
                            output: H
                        });
                        continue;
                    }
                    if (G === "!") {
                        if (u.noextglob !== true && D() === "(") {
                            if (D(2) !== "?" || !/[!=<:]/.test(D(3))) {
                                extglobOpen("negate", G);
                                continue;
                            }
                        }
                        if (u.nonegate !== true && m.index === 0) {
                            negate();
                            continue;
                        }
                    }
                    if (G === "+") {
                        if (u.noextglob !== true && D() === "(" && D(2) !== "?") {
                            extglobOpen("plus", G);
                            continue;
                        }
                        if (B && B.value === "(" || u.regex === false) {
                            push({
                                type: "plus",
                                value: G,
                                output: g
                            });
                            continue;
                        }
                        if (B && (B.type === "bracket" || B.type === "paren" || B.type === "brace") || m.parens > 0) {
                            push({
                                type: "plus",
                                value: G
                            });
                            continue;
                        }
                        push({
                            type: "plus",
                            value: g
                        });
                        continue;
                    }
                    if (G === "@") {
                        if (u.noextglob !== true && D() === "(" && D(2) !== "?") {
                            push({
                                type: "at",
                                extglob: true,
                                value: G,
                                output: ""
                            });
                            continue;
                        }
                        push({
                            type: "text",
                            value: G
                        });
                        continue;
                    }
                    if (G !== "*") {
                        if (G === "$" || G === "^") {
                            G = `\\${G}`;
                        }
                        const t = a.exec(remaining());
                        if (t) {
                            G += t[0];
                            m.index += t[0].length;
                        }
                        push({
                            type: "text",
                            value: G
                        });
                        continue;
                    }
                    if (B && (B.type === "globstar" || B.star === true)) {
                        B.type = "star";
                        B.star = true;
                        B.value += G;
                        B.output = k;
                        m.backtrack = true;
                        m.globstar = true;
                        consume(G);
                        continue;
                    }
                    let e = remaining();
                    if (u.noextglob !== true && /^\([^?]/.test(e)) {
                        extglobOpen("star", G);
                        continue;
                    }
                    if (B.type === "star") {
                        if (u.noglobstar === true) {
                            consume(G);
                            continue;
                        }
                        const n = B.prev;
                        const o = n.prev;
                        const s = n.type === "slash" || n.type === "bos";
                        const r = o && (o.type === "star" || o.type === "globstar");
                        if (u.bash === true && (!s || e[0] && e[0] !== "/")) {
                            push({
                                type: "star",
                                value: G,
                                output: ""
                            });
                            continue;
                        }
                        const a = m.braces > 0 && (n.type === "comma" || n.type === "brace");
                        const i = w.length && (n.type === "pipe" || n.type === "paren");
                        if (!s && n.type !== "paren" && !a && !i) {
                            push({
                                type: "star",
                                value: G,
                                output: ""
                            });
                            continue;
                        }
                        while(e.slice(0, 3) === "/**"){
                            const u = t[m.index + 4];
                            if (u && u !== "/") {
                                break;
                            }
                            e = e.slice(3);
                            consume("/**", 3);
                        }
                        if (n.type === "bos" && eos()) {
                            B.type = "globstar";
                            B.value += G;
                            B.output = globstar(u);
                            m.output = B.output;
                            m.globstar = true;
                            consume(G);
                            continue;
                        }
                        if (n.type === "slash" && n.prev.type !== "bos" && !r && eos()) {
                            m.output = m.output.slice(0, -(n.output + B.output).length);
                            n.output = `(?:${n.output}`;
                            B.type = "globstar";
                            B.output = globstar(u) + (u.strictSlashes ? ")" : "|$)");
                            B.value += G;
                            m.globstar = true;
                            m.output += n.output + B.output;
                            consume(G);
                            continue;
                        }
                        if (n.type === "slash" && n.prev.type !== "bos" && e[0] === "/") {
                            const t = e[1] !== void 0 ? "|$" : "";
                            m.output = m.output.slice(0, -(n.output + B.output).length);
                            n.output = `(?:${n.output}`;
                            B.type = "globstar";
                            B.output = `${globstar(u)}${b}|${b}${t})`;
                            B.value += G;
                            m.output += n.output + B.output;
                            m.globstar = true;
                            consume(G + M());
                            push({
                                type: "slash",
                                value: "/",
                                output: ""
                            });
                            continue;
                        }
                        if (n.type === "bos" && e[0] === "/") {
                            B.type = "globstar";
                            B.value += G;
                            B.output = `(?:^|${b}|${globstar(u)}${b})`;
                            m.output = B.output;
                            m.globstar = true;
                            consume(G + M());
                            push({
                                type: "slash",
                                value: "/",
                                output: ""
                            });
                            continue;
                        }
                        m.output = m.output.slice(0, -B.output.length);
                        B.type = "globstar";
                        B.output = globstar(u);
                        B.value += G;
                        m.output += B.output;
                        m.globstar = true;
                        consume(G);
                        continue;
                    }
                    const n = {
                        type: "star",
                        value: G,
                        output: k
                    };
                    if (u.bash === true) {
                        n.output = ".*?";
                        if (B.type === "bos" || B.type === "slash") {
                            n.output = T + n.output;
                        }
                        push(n);
                        continue;
                    }
                    if (B && (B.type === "bracket" || B.type === "paren") && u.regex === true) {
                        n.output = G;
                        push(n);
                        continue;
                    }
                    if (m.index === m.start || B.type === "slash" || B.type === "dot") {
                        if (B.type === "dot") {
                            m.output += x;
                            B.output += x;
                        } else if (u.dot === true) {
                            m.output += S;
                            B.output += S;
                        } else {
                            m.output += T;
                            B.output += T;
                        }
                        if (D() !== "*") {
                            m.output += C;
                            B.output += C;
                        }
                    }
                    push(n);
                }
                while(m.brackets > 0){
                    if (u.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "]"));
                    m.output = o.escapeLast(m.output, "[");
                    decrement("brackets");
                }
                while(m.parens > 0){
                    if (u.strictBrackets === true) throw new SyntaxError(syntaxError("closing", ")"));
                    m.output = o.escapeLast(m.output, "(");
                    decrement("parens");
                }
                while(m.braces > 0){
                    if (u.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "}"));
                    m.output = o.escapeLast(m.output, "{");
                    decrement("braces");
                }
                if (u.strictSlashes !== true && (B.type === "star" || B.type === "bracket")) {
                    push({
                        type: "maybe_slash",
                        value: "",
                        output: `${b}?`
                    });
                }
                if (m.backtrack === true) {
                    m.output = "";
                    for (const t of m.tokens){
                        m.output += t.output != null ? t.output : t.value;
                        if (t.suffix) {
                            m.output += t.suffix;
                        }
                    }
                }
                return m;
            };
            parse.fastpaths = (t, e)=>{
                const u = {
                    ...e
                };
                const r = typeof u.maxLength === "number" ? Math.min(s, u.maxLength) : s;
                const a = t.length;
                if (a > r) {
                    throw new SyntaxError(`Input length: ${a}, exceeds maximum allowed length: ${r}`);
                }
                t = c[t] || t;
                const { DOT_LITERAL: i, SLASH_LITERAL: p, ONE_CHAR: l, DOTS_SLASH: f, NO_DOT: A, NO_DOTS: _, NO_DOTS_SLASH: R, STAR: E, START_ANCHOR: h } = n.globChars(u.windows);
                const g = u.dot ? _ : A;
                const b = u.dot ? R : A;
                const C = u.capture ? "" : "?:";
                const y = {
                    negated: false,
                    prefix: ""
                };
                let $ = u.bash === true ? ".*?" : E;
                if (u.capture) {
                    $ = `(${$})`;
                }
                const globstar = (t)=>{
                    if (t.noglobstar === true) return $;
                    return `(${C}(?:(?!${h}${t.dot ? f : i}).)*?)`;
                };
                const create = (t)=>{
                    switch(t){
                        case "*":
                            return `${g}${l}${$}`;
                        case ".*":
                            return `${i}${l}${$}`;
                        case "*.*":
                            return `${g}${$}${i}${l}${$}`;
                        case "*/*":
                            return `${g}${$}${p}${l}${b}${$}`;
                        case "**":
                            return g + globstar(u);
                        case "**/*":
                            return `(?:${g}${globstar(u)}${p})?${b}${l}${$}`;
                        case "**/*.*":
                            return `(?:${g}${globstar(u)}${p})?${b}${$}${i}${l}${$}`;
                        case "**/.*":
                            return `(?:${g}${globstar(u)}${p})?${i}${l}${$}`;
                        default:
                            {
                                const e = /^(.*?)\.(\w+)$/.exec(t);
                                if (!e) return;
                                const u = create(e[1]);
                                if (!u) return;
                                return u + i + e[2];
                            }
                    }
                };
                const x = o.removePrefix(t, y);
                let S = create(x);
                if (S && u.strictSlashes !== true) {
                    S += `${p}?`;
                }
                return S;
            };
            t.exports = parse;
        },
        510: (t, e, u)=>{
            const n = u(716);
            const o = u(697);
            const s = u(96);
            const r = u(154);
            const isObject = (t)=>t && typeof t === "object" && !Array.isArray(t);
            const picomatch = (t, e, u = false)=>{
                if (Array.isArray(t)) {
                    const n = t.map((t)=>picomatch(t, e, u));
                    const arrayMatcher = (t)=>{
                        for (const e of n){
                            const u = e(t);
                            if (u) return u;
                        }
                        return false;
                    };
                    return arrayMatcher;
                }
                const n = isObject(t) && t.tokens && t.input;
                if (t === "" || typeof t !== "string" && !n) {
                    throw new TypeError("Expected pattern to be a non-empty string");
                }
                const o = e || {};
                const s = o.windows;
                const r = n ? picomatch.compileRe(t, e) : picomatch.makeRe(t, e, false, true);
                const a = r.state;
                delete r.state;
                let isIgnored = ()=>false;
                if (o.ignore) {
                    const t = {
                        ...e,
                        ignore: null,
                        onMatch: null,
                        onResult: null
                    };
                    isIgnored = picomatch(o.ignore, t, u);
                }
                const matcher = (u, n = false)=>{
                    const { isMatch: i, match: c, output: p } = picomatch.test(u, r, e, {
                        glob: t,
                        posix: s
                    });
                    const l = {
                        glob: t,
                        state: a,
                        regex: r,
                        posix: s,
                        input: u,
                        output: p,
                        match: c,
                        isMatch: i
                    };
                    if (typeof o.onResult === "function") {
                        o.onResult(l);
                    }
                    if (i === false) {
                        l.isMatch = false;
                        return n ? l : false;
                    }
                    if (isIgnored(u)) {
                        if (typeof o.onIgnore === "function") {
                            o.onIgnore(l);
                        }
                        l.isMatch = false;
                        return n ? l : false;
                    }
                    if (typeof o.onMatch === "function") {
                        o.onMatch(l);
                    }
                    return n ? l : true;
                };
                if (u) {
                    matcher.state = a;
                }
                return matcher;
            };
            picomatch.test = (t, e, u, { glob: n, posix: o } = {})=>{
                if (typeof t !== "string") {
                    throw new TypeError("Expected input to be a string");
                }
                if (t === "") {
                    return {
                        isMatch: false,
                        output: ""
                    };
                }
                const r = u || {};
                const a = r.format || (o ? s.toPosixSlashes : null);
                let i = t === n;
                let c = i && a ? a(t) : t;
                if (i === false) {
                    c = a ? a(t) : t;
                    i = c === n;
                }
                if (i === false || r.capture === true) {
                    if (r.matchBase === true || r.basename === true) {
                        i = picomatch.matchBase(t, e, u, o);
                    } else {
                        i = e.exec(c);
                    }
                }
                return {
                    isMatch: Boolean(i),
                    match: i,
                    output: c
                };
            };
            picomatch.matchBase = (t, e, u)=>{
                const n = e instanceof RegExp ? e : picomatch.makeRe(e, u);
                return n.test(s.basename(t));
            };
            picomatch.isMatch = (t, e, u)=>picomatch(e, u)(t);
            picomatch.parse = (t, e)=>{
                if (Array.isArray(t)) return t.map((t)=>picomatch.parse(t, e));
                return o(t, {
                    ...e,
                    fastpaths: false
                });
            };
            picomatch.scan = (t, e)=>n(t, e);
            picomatch.compileRe = (t, e, u = false, n = false)=>{
                if (u === true) {
                    return t.output;
                }
                const o = e || {};
                const s = o.contains ? "" : "^";
                const r = o.contains ? "" : "$";
                let a = `${s}(?:${t.output})${r}`;
                if (t && t.negated === true) {
                    a = `^(?!${a}).*$`;
                }
                const i = picomatch.toRegex(a, e);
                if (n === true) {
                    i.state = t;
                }
                return i;
            };
            picomatch.makeRe = (t, e = {}, u = false, n = false)=>{
                if (!t || typeof t !== "string") {
                    throw new TypeError("Expected a non-empty string");
                }
                let s = {
                    negated: false,
                    fastpaths: true
                };
                if (e.fastpaths !== false && (t[0] === "." || t[0] === "*")) {
                    s.output = o.fastpaths(t, e);
                }
                if (!s.output) {
                    s = o(t, e);
                }
                return picomatch.compileRe(s, e, u, n);
            };
            picomatch.toRegex = (t, e)=>{
                try {
                    const u = e || {};
                    return new RegExp(t, u.flags || (u.nocase ? "i" : ""));
                } catch (t) {
                    if (e && e.debug === true) throw t;
                    return /$^/;
                }
            };
            picomatch.constants = r;
            t.exports = picomatch;
        },
        716: (t, e, u)=>{
            const n = u(96);
            const { CHAR_ASTERISK: o, CHAR_AT: s, CHAR_BACKWARD_SLASH: r, CHAR_COMMA: a, CHAR_DOT: i, CHAR_EXCLAMATION_MARK: c, CHAR_FORWARD_SLASH: p, CHAR_LEFT_CURLY_BRACE: l, CHAR_LEFT_PARENTHESES: f, CHAR_LEFT_SQUARE_BRACKET: A, CHAR_PLUS: _, CHAR_QUESTION_MARK: R, CHAR_RIGHT_CURLY_BRACE: E, CHAR_RIGHT_PARENTHESES: h, CHAR_RIGHT_SQUARE_BRACKET: g } = u(154);
            const isPathSeparator = (t)=>t === p || t === r;
            const depth = (t)=>{
                if (t.isPrefix !== true) {
                    t.depth = t.isGlobstar ? Infinity : 1;
                }
            };
            const scan = (t, e)=>{
                const u = e || {};
                const b = t.length - 1;
                const C = u.parts === true || u.scanToEnd === true;
                const y = [];
                const $ = [];
                const x = [];
                let S = t;
                let H = -1;
                let v = 0;
                let d = 0;
                let L = false;
                let T = false;
                let O = false;
                let k = false;
                let m = false;
                let w = false;
                let N = false;
                let I = false;
                let B = false;
                let G = false;
                let D = 0;
                let M;
                let P;
                let K = {
                    value: "",
                    depth: 0,
                    isGlob: false
                };
                const eos = ()=>H >= b;
                const peek = ()=>S.charCodeAt(H + 1);
                const advance = ()=>{
                    M = P;
                    return S.charCodeAt(++H);
                };
                while(H < b){
                    P = advance();
                    let t;
                    if (P === r) {
                        N = K.backslashes = true;
                        P = advance();
                        if (P === l) {
                            w = true;
                        }
                        continue;
                    }
                    if (w === true || P === l) {
                        D++;
                        while(eos() !== true && (P = advance())){
                            if (P === r) {
                                N = K.backslashes = true;
                                advance();
                                continue;
                            }
                            if (P === l) {
                                D++;
                                continue;
                            }
                            if (w !== true && P === i && (P = advance()) === i) {
                                L = K.isBrace = true;
                                O = K.isGlob = true;
                                G = true;
                                if (C === true) {
                                    continue;
                                }
                                break;
                            }
                            if (w !== true && P === a) {
                                L = K.isBrace = true;
                                O = K.isGlob = true;
                                G = true;
                                if (C === true) {
                                    continue;
                                }
                                break;
                            }
                            if (P === E) {
                                D--;
                                if (D === 0) {
                                    w = false;
                                    L = K.isBrace = true;
                                    G = true;
                                    break;
                                }
                            }
                        }
                        if (C === true) {
                            continue;
                        }
                        break;
                    }
                    if (P === p) {
                        y.push(H);
                        $.push(K);
                        K = {
                            value: "",
                            depth: 0,
                            isGlob: false
                        };
                        if (G === true) continue;
                        if (M === i && H === v + 1) {
                            v += 2;
                            continue;
                        }
                        d = H + 1;
                        continue;
                    }
                    if (u.noext !== true) {
                        const t = P === _ || P === s || P === o || P === R || P === c;
                        if (t === true && peek() === f) {
                            O = K.isGlob = true;
                            k = K.isExtglob = true;
                            G = true;
                            if (P === c && H === v) {
                                B = true;
                            }
                            if (C === true) {
                                while(eos() !== true && (P = advance())){
                                    if (P === r) {
                                        N = K.backslashes = true;
                                        P = advance();
                                        continue;
                                    }
                                    if (P === h) {
                                        O = K.isGlob = true;
                                        G = true;
                                        break;
                                    }
                                }
                                continue;
                            }
                            break;
                        }
                    }
                    if (P === o) {
                        if (M === o) m = K.isGlobstar = true;
                        O = K.isGlob = true;
                        G = true;
                        if (C === true) {
                            continue;
                        }
                        break;
                    }
                    if (P === R) {
                        O = K.isGlob = true;
                        G = true;
                        if (C === true) {
                            continue;
                        }
                        break;
                    }
                    if (P === A) {
                        while(eos() !== true && (t = advance())){
                            if (t === r) {
                                N = K.backslashes = true;
                                advance();
                                continue;
                            }
                            if (t === g) {
                                T = K.isBracket = true;
                                O = K.isGlob = true;
                                G = true;
                                break;
                            }
                        }
                        if (C === true) {
                            continue;
                        }
                        break;
                    }
                    if (u.nonegate !== true && P === c && H === v) {
                        I = K.negated = true;
                        v++;
                        continue;
                    }
                    if (u.noparen !== true && P === f) {
                        O = K.isGlob = true;
                        if (C === true) {
                            while(eos() !== true && (P = advance())){
                                if (P === f) {
                                    N = K.backslashes = true;
                                    P = advance();
                                    continue;
                                }
                                if (P === h) {
                                    G = true;
                                    break;
                                }
                            }
                            continue;
                        }
                        break;
                    }
                    if (O === true) {
                        G = true;
                        if (C === true) {
                            continue;
                        }
                        break;
                    }
                }
                if (u.noext === true) {
                    k = false;
                    O = false;
                }
                let U = S;
                let X = "";
                let F = "";
                if (v > 0) {
                    X = S.slice(0, v);
                    S = S.slice(v);
                    d -= v;
                }
                if (U && O === true && d > 0) {
                    U = S.slice(0, d);
                    F = S.slice(d);
                } else if (O === true) {
                    U = "";
                    F = S;
                } else {
                    U = S;
                }
                if (U && U !== "" && U !== "/" && U !== S) {
                    if (isPathSeparator(U.charCodeAt(U.length - 1))) {
                        U = U.slice(0, -1);
                    }
                }
                if (u.unescape === true) {
                    if (F) F = n.removeBackslashes(F);
                    if (U && N === true) {
                        U = n.removeBackslashes(U);
                    }
                }
                const Q = {
                    prefix: X,
                    input: t,
                    start: v,
                    base: U,
                    glob: F,
                    isBrace: L,
                    isBracket: T,
                    isGlob: O,
                    isExtglob: k,
                    isGlobstar: m,
                    negated: I,
                    negatedExtglob: B
                };
                if (u.tokens === true) {
                    Q.maxDepth = 0;
                    if (!isPathSeparator(P)) {
                        $.push(K);
                    }
                    Q.tokens = $;
                }
                if (u.parts === true || u.tokens === true) {
                    let e;
                    for(let n = 0; n < y.length; n++){
                        const o = e ? e + 1 : v;
                        const s = y[n];
                        const r = t.slice(o, s);
                        if (u.tokens) {
                            if (n === 0 && v !== 0) {
                                $[n].isPrefix = true;
                                $[n].value = X;
                            } else {
                                $[n].value = r;
                            }
                            depth($[n]);
                            Q.maxDepth += $[n].depth;
                        }
                        if (n !== 0 || r !== "") {
                            x.push(r);
                        }
                        e = s;
                    }
                    if (e && e + 1 < t.length) {
                        const n = t.slice(e + 1);
                        x.push(n);
                        if (u.tokens) {
                            $[$.length - 1].value = n;
                            depth($[$.length - 1]);
                            Q.maxDepth += $[$.length - 1].depth;
                        }
                    }
                    Q.slashes = y;
                    Q.parts = x;
                }
                return Q;
            };
            t.exports = scan;
        },
        96: (t, e, u)=>{
            const { REGEX_BACKSLASH: n, REGEX_REMOVE_BACKSLASH: o, REGEX_SPECIAL_CHARS: s, REGEX_SPECIAL_CHARS_GLOBAL: r } = u(154);
            e.isObject = (t)=>t !== null && typeof t === "object" && !Array.isArray(t);
            e.hasRegexChars = (t)=>s.test(t);
            e.isRegexChar = (t)=>t.length === 1 && e.hasRegexChars(t);
            e.escapeRegex = (t)=>t.replace(r, "\\$1");
            e.toPosixSlashes = (t)=>t.replace(n, "/");
            e.removeBackslashes = (t)=>t.replace(o, (t)=>t === "\\" ? "" : t);
            e.escapeLast = (t, u, n)=>{
                const o = t.lastIndexOf(u, n);
                if (o === -1) return t;
                if (t[o - 1] === "\\") return e.escapeLast(t, u, o - 1);
                return `${t.slice(0, o)}\\${t.slice(o)}`;
            };
            e.removePrefix = (t, e = {})=>{
                let u = t;
                if (u.startsWith("./")) {
                    u = u.slice(2);
                    e.prefix = "./";
                }
                return u;
            };
            e.wrapOutput = (t, e = {}, u = {})=>{
                const n = u.contains ? "" : "^";
                const o = u.contains ? "" : "$";
                let s = `${n}(?:${t})${o}`;
                if (e.negated === true) {
                    s = `(?:^(?!${s}).*$)`;
                }
                return s;
            };
            e.basename = (t, { windows: e } = {})=>{
                const u = t.split(e ? /[\\/]/ : "/");
                const n = u[u.length - 1];
                if (n === "") {
                    return u[u.length - 2];
                }
                return n;
            };
        }
    };
    var e = {};
    function __nccwpck_require__(u) {
        var n = e[u];
        if (n !== undefined) {
            return n.exports;
        }
        var o = e[u] = {
            exports: {}
        };
        var s = true;
        try {
            t[u](o, o.exports, __nccwpck_require__);
            s = false;
        } finally{
            if (s) delete e[u];
        }
        return o.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = ("TURBOPACK compile-time value", "/ROOT/node_modules/next/dist/compiled/picomatch") + "/";
    var u = __nccwpck_require__(170);
    module.exports = u;
})();
}),
"[project]/node_modules/next/dist/shared/lib/match-local-pattern.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    hasLocalMatch: null,
    matchLocalPattern: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    hasLocalMatch: function() {
        return hasLocalMatch;
    },
    matchLocalPattern: function() {
        return matchLocalPattern;
    }
});
const _picomatch = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/picomatch/index.js [app-ssr] (ecmascript)");
function matchLocalPattern(pattern, url) {
    if (pattern.search !== undefined) {
        if (pattern.search !== url.search) {
            return false;
        }
    }
    if (!(0, _picomatch.makeRe)(pattern.pathname ?? '**', {
        dot: true
    }).test(url.pathname)) {
        return false;
    }
    return true;
}
function hasLocalMatch(localPatterns, urlPathAndQuery) {
    if (!localPatterns) {
        // if the user didn't define "localPatterns", we allow all local images
        return true;
    }
    const url = new URL(urlPathAndQuery, 'http://n');
    return localPatterns.some((p)=>matchLocalPattern(p, url));
} //# sourceMappingURL=match-local-pattern.js.map
}),
"[project]/node_modules/next/dist/shared/lib/match-remote-pattern.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    hasRemoteMatch: null,
    matchRemotePattern: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    hasRemoteMatch: function() {
        return hasRemoteMatch;
    },
    matchRemotePattern: function() {
        return matchRemotePattern;
    }
});
const _picomatch = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/picomatch/index.js [app-ssr] (ecmascript)");
function matchRemotePattern(pattern, url) {
    if (pattern.protocol !== undefined) {
        if (pattern.protocol.replace(/:$/, '') !== url.protocol.replace(/:$/, '')) {
            return false;
        }
    }
    if (pattern.port !== undefined) {
        if (pattern.port !== url.port) {
            return false;
        }
    }
    if (pattern.hostname === undefined) {
        throw Object.defineProperty(new Error(`Pattern should define hostname but found\n${JSON.stringify(pattern)}`), "__NEXT_ERROR_CODE", {
            value: "E410",
            enumerable: false,
            configurable: true
        });
    } else {
        if (!(0, _picomatch.makeRe)(pattern.hostname).test(url.hostname)) {
            return false;
        }
    }
    if (pattern.search !== undefined) {
        if (pattern.search !== url.search) {
            return false;
        }
    }
    // Should be the same as writeImagesManifest()
    if (!(0, _picomatch.makeRe)(pattern.pathname ?? '**', {
        dot: true
    }).test(url.pathname)) {
        return false;
    }
    return true;
}
function hasRemoteMatch(domains, remotePatterns, url) {
    return domains.some((domain)=>url.hostname === domain) || remotePatterns.some((p)=>matchRemotePattern(p, url));
} //# sourceMappingURL=match-remote-pattern.js.map
}),
"[project]/node_modules/next/dist/shared/lib/image-loader.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _findclosestquality = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/find-closest-quality.js [app-ssr] (ecmascript)");
function defaultLoader({ config, src, width, quality }) {
    if (src.startsWith('/') && src.includes('?') && config.localPatterns?.length === 1 && config.localPatterns[0].pathname === '**' && config.localPatterns[0].search === '') {
        throw Object.defineProperty(new Error(`Image with src "${src}" is using a query string which is not configured in images.localPatterns.` + `\nRead more: https://nextjs.org/docs/messages/next-image-unconfigured-localpatterns`), "__NEXT_ERROR_CODE", {
            value: "E871",
            enumerable: false,
            configurable: true
        });
    }
    if ("TURBOPACK compile-time truthy", 1) {
        const missingValues = [];
        // these should always be provided but make sure they are
        if (!src) missingValues.push('src');
        if (!width) missingValues.push('width');
        if (missingValues.length > 0) {
            throw Object.defineProperty(new Error(`Next Image Optimization requires ${missingValues.join(', ')} to be provided. Make sure you pass them as props to the \`next/image\` component. Received: ${JSON.stringify({
                src,
                width,
                quality
            })}`), "__NEXT_ERROR_CODE", {
                value: "E188",
                enumerable: false,
                configurable: true
            });
        }
        if (src.startsWith('//')) {
            throw Object.defineProperty(new Error(`Failed to parse src "${src}" on \`next/image\`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)`), "__NEXT_ERROR_CODE", {
                value: "E360",
                enumerable: false,
                configurable: true
            });
        }
        if (src.startsWith('/') && config.localPatterns) {
            if ("TURBOPACK compile-time truthy", 1) {
                // We use dynamic require because this should only error in development
                const { hasLocalMatch } = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/match-local-pattern.js [app-ssr] (ecmascript)");
                if (!hasLocalMatch(config.localPatterns, src)) {
                    throw Object.defineProperty(new Error(`Invalid src prop (${src}) on \`next/image\` does not match \`images.localPatterns\` configured in your \`next.config.js\`\n` + `See more info: https://nextjs.org/docs/messages/next-image-unconfigured-localpatterns`), "__NEXT_ERROR_CODE", {
                        value: "E426",
                        enumerable: false,
                        configurable: true
                    });
                }
            }
        }
        if (!src.startsWith('/') && (config.domains || config.remotePatterns)) {
            let parsedSrc;
            try {
                parsedSrc = new URL(src);
            } catch (err) {
                console.error(err);
                throw Object.defineProperty(new Error(`Failed to parse src "${src}" on \`next/image\`, if using relative image it must start with a leading slash "/" or be an absolute URL (http:// or https://)`), "__NEXT_ERROR_CODE", {
                    value: "E63",
                    enumerable: false,
                    configurable: true
                });
            }
            if ("TURBOPACK compile-time truthy", 1) {
                // We use dynamic require because this should only error in development
                const { hasRemoteMatch } = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/match-remote-pattern.js [app-ssr] (ecmascript)");
                if (!hasRemoteMatch(config.domains, config.remotePatterns, parsedSrc)) {
                    throw Object.defineProperty(new Error(`Invalid src prop (${src}) on \`next/image\`, hostname "${parsedSrc.hostname}" is not configured under images in your \`next.config.js\`\n` + `See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host`), "__NEXT_ERROR_CODE", {
                        value: "E231",
                        enumerable: false,
                        configurable: true
                    });
                }
            }
        }
    }
    const q = (0, _findclosestquality.findClosestQuality)(quality, config);
    return `${config.path}?url=${encodeURIComponent(src)}&w=${width}&q=${q}${src.startsWith('/_next/static/media/') && ("TURBOPACK compile-time value", false) ? "TURBOPACK unreachable" : ''}`;
}
// We use this to determine if the import is the default loader
// or a custom loader defined by the user in next.config.js
defaultLoader.__next_img_default = true;
const _default = defaultLoader; //# sourceMappingURL=image-loader.js.map
}),
"[project]/node_modules/next/dist/client/use-merged-ref.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useMergedRef", {
    enumerable: true,
    get: function() {
        return useMergedRef;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
function useMergedRef(refA, refB) {
    const cleanupA = (0, _react.useRef)(null);
    const cleanupB = (0, _react.useRef)(null);
    // NOTE: In theory, we could skip the wrapping if only one of the refs is non-null.
    // (this happens often if the user doesn't pass a ref to Link/Form/Image)
    // But this can cause us to leak a cleanup-ref into user code (previously via `<Link legacyBehavior>`),
    // and the user might pass that ref into ref-merging library that doesn't support cleanup refs
    // (because it hasn't been updated for React 19)
    // which can then cause things to blow up, because a cleanup-returning ref gets called with `null`.
    // So in practice, it's safer to be defensive and always wrap the ref, even on React 19.
    return (0, _react.useCallback)((current)=>{
        if (current === null) {
            const cleanupFnA = cleanupA.current;
            if (cleanupFnA) {
                cleanupA.current = null;
                cleanupFnA();
            }
            const cleanupFnB = cleanupB.current;
            if (cleanupFnB) {
                cleanupB.current = null;
                cleanupFnB();
            }
        } else {
            if (refA) {
                cleanupA.current = applyRef(refA, current);
            }
            if (refB) {
                cleanupB.current = applyRef(refB, current);
            }
        }
    }, [
        refA,
        refB
    ]);
}
function applyRef(refA, current) {
    if (typeof refA === 'function') {
        const cleanup = refA(current);
        if (typeof cleanup === 'function') {
            return cleanup;
        } else {
            return ()=>refA(null);
        }
    } else {
        refA.current = current;
        return ()=>{
            refA.current = null;
        };
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=use-merged-ref.js.map
}),
"[project]/node_modules/next/dist/client/image-component.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "Image", {
    enumerable: true,
    get: function() {
        return Image;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-ssr] (ecmascript)");
const _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-ssr] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"));
const _reactdom = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js [app-ssr] (ecmascript)"));
const _head = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/head.js [app-ssr] (ecmascript)"));
const _getimgprops = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/get-img-props.js [app-ssr] (ecmascript)");
const _imageconfig = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-config.js [app-ssr] (ecmascript)");
const _imageconfigcontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/contexts/image-config-context.js [app-ssr] (ecmascript)");
const _warnonce = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [app-ssr] (ecmascript)");
const _routercontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/contexts/router-context.js [app-ssr] (ecmascript)");
const _imageloader = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-loader.js [app-ssr] (ecmascript)"));
const _usemergedref = __turbopack_context__.r("[project]/node_modules/next/dist/client/use-merged-ref.js [app-ssr] (ecmascript)");
// This is replaced by webpack define plugin
const configEnv = ("TURBOPACK compile-time value", {
    "deviceSizes": ("TURBOPACK compile-time value", [
        ("TURBOPACK compile-time value", 640),
        ("TURBOPACK compile-time value", 750),
        ("TURBOPACK compile-time value", 828),
        ("TURBOPACK compile-time value", 1080),
        ("TURBOPACK compile-time value", 1200),
        ("TURBOPACK compile-time value", 1920),
        ("TURBOPACK compile-time value", 2048),
        ("TURBOPACK compile-time value", 3840)
    ]),
    "imageSizes": ("TURBOPACK compile-time value", [
        ("TURBOPACK compile-time value", 32),
        ("TURBOPACK compile-time value", 48),
        ("TURBOPACK compile-time value", 64),
        ("TURBOPACK compile-time value", 96),
        ("TURBOPACK compile-time value", 128),
        ("TURBOPACK compile-time value", 256),
        ("TURBOPACK compile-time value", 384)
    ]),
    "qualities": ("TURBOPACK compile-time value", [
        ("TURBOPACK compile-time value", 75)
    ]),
    "path": ("TURBOPACK compile-time value", "/_next/image"),
    "loader": ("TURBOPACK compile-time value", "default"),
    "dangerouslyAllowSVG": ("TURBOPACK compile-time value", false),
    "unoptimized": ("TURBOPACK compile-time value", false),
    "domains": ("TURBOPACK compile-time value", []),
    "remotePatterns": ("TURBOPACK compile-time value", []),
    "localPatterns": ("TURBOPACK compile-time value", [
        ("TURBOPACK compile-time value", {
            "pathname": ("TURBOPACK compile-time value", "**"),
            "search": ("TURBOPACK compile-time value", "")
        })
    ])
});
if ("TURBOPACK compile-time truthy", 1) {
    ;
    globalThis.__NEXT_IMAGE_IMPORTED = true;
}
// See https://stackoverflow.com/q/39777833/266535 for why we use this ref
// handler instead of the img's onLoad attribute.
function handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput) {
    const src = img?.src;
    if (!img || img['data-loaded-src'] === src) {
        return;
    }
    img['data-loaded-src'] = src;
    const p = 'decode' in img ? img.decode() : Promise.resolve();
    p.catch(()=>{}).then(()=>{
        if (!img.parentElement || !img.isConnected) {
            // Exit early in case of race condition:
            // - onload() is called
            // - decode() is called but incomplete
            // - unmount is called
            // - decode() completes
            return;
        }
        if (placeholder !== 'empty') {
            setBlurComplete(true);
        }
        if (onLoadRef?.current) {
            // Since we don't have the SyntheticEvent here,
            // we must create one with the same shape.
            // See https://reactjs.org/docs/events.html
            const event = new Event('load');
            Object.defineProperty(event, 'target', {
                writable: false,
                value: img
            });
            let prevented = false;
            let stopped = false;
            onLoadRef.current({
                ...event,
                nativeEvent: event,
                currentTarget: img,
                target: img,
                isDefaultPrevented: ()=>prevented,
                isPropagationStopped: ()=>stopped,
                persist: ()=>{},
                preventDefault: ()=>{
                    prevented = true;
                    event.preventDefault();
                },
                stopPropagation: ()=>{
                    stopped = true;
                    event.stopPropagation();
                }
            });
        }
        if (onLoadingCompleteRef?.current) {
            onLoadingCompleteRef.current(img);
        }
        if ("TURBOPACK compile-time truthy", 1) {
            const origSrc = new URL(src, 'http://n').searchParams.get('url') || src;
            if (img.getAttribute('data-nimg') === 'fill') {
                if (!unoptimized && (!sizesInput || sizesInput === '100vw')) {
                    let widthViewportRatio = img.getBoundingClientRect().width / window.innerWidth;
                    if (widthViewportRatio < 0.6) {
                        if (sizesInput === '100vw') {
                            (0, _warnonce.warnOnce)(`Image with src "${origSrc}" has "fill" prop and "sizes" prop of "100vw", but image is not rendered at full viewport width. Please adjust "sizes" to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes`);
                        } else {
                            (0, _warnonce.warnOnce)(`Image with src "${origSrc}" has "fill" but is missing "sizes" prop. Please add it to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes`);
                        }
                    }
                }
                if (img.parentElement) {
                    const { position } = window.getComputedStyle(img.parentElement);
                    const valid = [
                        'absolute',
                        'fixed',
                        'relative'
                    ];
                    if (!valid.includes(position)) {
                        (0, _warnonce.warnOnce)(`Image with src "${origSrc}" has "fill" and parent element with invalid "position". Provided "${position}" should be one of ${valid.map(String).join(',')}.`);
                    }
                }
                if (img.height === 0) {
                    (0, _warnonce.warnOnce)(`Image with src "${origSrc}" has "fill" and a height value of 0. This is likely because the parent element of the image has not been styled to have a set height.`);
                }
            }
            const heightModified = img.height.toString() !== img.getAttribute('height');
            const widthModified = img.width.toString() !== img.getAttribute('width');
            if (heightModified && !widthModified || !heightModified && widthModified) {
                (0, _warnonce.warnOnce)(`Image with src "${origSrc}" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles 'width: "auto"' or 'height: "auto"' to maintain the aspect ratio.`);
            }
        }
    });
}
function getDynamicProps(fetchPriority) {
    if (Boolean(_react.use)) {
        // In React 19.0.0 or newer, we must use camelCase
        // prop to avoid "Warning: Invalid DOM property".
        // See https://github.com/facebook/react/pull/25927
        return {
            fetchPriority
        };
    }
    // In React 18.2.0 or older, we must use lowercase prop
    // to avoid "Warning: Invalid DOM property".
    return {
        fetchpriority: fetchPriority
    };
}
const ImageElement = /*#__PURE__*/ (0, _react.forwardRef)(({ src, srcSet, sizes, height, width, decoding, className, style, fetchPriority, placeholder, loading, unoptimized, fill, onLoadRef, onLoadingCompleteRef, setBlurComplete, setShowAltText, sizesInput, onLoad, onError, ...rest }, forwardedRef)=>{
    const ownRef = (0, _react.useCallback)((img)=>{
        if (!img) {
            return;
        }
        if (onError) {
            // If the image has an error before react hydrates, then the error is lost.
            // The workaround is to wait until the image is mounted which is after hydration,
            // then we set the src again to trigger the error handler (if there was an error).
            // eslint-disable-next-line no-self-assign
            img.src = img.src;
        }
        if ("TURBOPACK compile-time truthy", 1) {
            if (!src) {
                console.error(`Image is missing required "src" property:`, img);
            }
            if (img.getAttribute('alt') === null) {
                console.error(`Image is missing required "alt" property. Please add Alternative Text to describe the image for screen readers and search engines.`);
            }
        }
        if (img.complete) {
            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);
        }
    }, [
        src,
        placeholder,
        onLoadRef,
        onLoadingCompleteRef,
        setBlurComplete,
        onError,
        unoptimized,
        sizesInput
    ]);
    const ref = (0, _usemergedref.useMergedRef)(forwardedRef, ownRef);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)("img", {
        ...rest,
        ...getDynamicProps(fetchPriority),
        // It's intended to keep `loading` before `src` because React updates
        // props in order which causes Safari/Firefox to not lazy load properly.
        // See https://github.com/facebook/react/issues/25883
        loading: loading,
        width: width,
        height: height,
        decoding: decoding,
        "data-nimg": fill ? 'fill' : '1',
        className: className,
        style: style,
        // It's intended to keep `src` the last attribute because React updates
        // attributes in order. If we keep `src` the first one, Safari will
        // immediately start to fetch `src`, before `sizes` and `srcSet` are even
        // updated by React. That causes multiple unnecessary requests if `srcSet`
        // and `sizes` are defined.
        // This bug cannot be reproduced in Chrome or Firefox.
        sizes: sizes,
        srcSet: srcSet,
        src: src,
        ref: ref,
        onLoad: (event)=>{
            const img = event.currentTarget;
            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);
        },
        onError: (event)=>{
            // if the real image fails to load, this will ensure "alt" is visible
            setShowAltText(true);
            if (placeholder !== 'empty') {
                // If the real image fails to load, this will still remove the placeholder.
                setBlurComplete(true);
            }
            if (onError) {
                onError(event);
            }
        }
    });
});
function ImagePreload({ isAppRouter, imgAttributes }) {
    const opts = {
        as: 'image',
        imageSrcSet: imgAttributes.srcSet,
        imageSizes: imgAttributes.sizes,
        crossOrigin: imgAttributes.crossOrigin,
        referrerPolicy: imgAttributes.referrerPolicy,
        ...getDynamicProps(imgAttributes.fetchPriority)
    };
    if (isAppRouter && _reactdom.default.preload) {
        _reactdom.default.preload(imgAttributes.src, opts);
        return null;
    }
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_head.default, {
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)("link", {
            rel: "preload",
            // Note how we omit the `href` attribute, as it would only be relevant
            // for browsers that do not support `imagesrcset`, and in those cases
            // it would cause the incorrect image to be preloaded.
            //
            // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset
            href: imgAttributes.srcSet ? undefined : imgAttributes.src,
            ...opts
        }, '__nimg-' + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes)
    });
}
const Image = /*#__PURE__*/ (0, _react.forwardRef)((props, forwardedRef)=>{
    const pagesRouter = (0, _react.useContext)(_routercontextsharedruntime.RouterContext);
    // We're in the app directory if there is no pages router.
    const isAppRouter = !pagesRouter;
    const configContext = (0, _react.useContext)(_imageconfigcontextsharedruntime.ImageConfigContext);
    const config = (0, _react.useMemo)(()=>{
        const c = configEnv || configContext || _imageconfig.imageConfigDefault;
        const allSizes = [
            ...c.deviceSizes,
            ...c.imageSizes
        ].sort((a, b)=>a - b);
        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);
        const qualities = c.qualities?.sort((a, b)=>a - b);
        return {
            ...c,
            allSizes,
            deviceSizes,
            qualities,
            // During the SSR, configEnv (__NEXT_IMAGE_OPTS) does not include
            // security sensitive configs like `localPatterns`, which is needed
            // during the server render to ensure it's validated. Therefore use
            // configContext, which holds the config from the server for validation.
            localPatterns: ("TURBOPACK compile-time truthy", 1) ? configContext?.localPatterns : "TURBOPACK unreachable"
        };
    }, [
        configContext
    ]);
    const { onLoad, onLoadingComplete } = props;
    const onLoadRef = (0, _react.useRef)(onLoad);
    (0, _react.useEffect)(()=>{
        onLoadRef.current = onLoad;
    }, [
        onLoad
    ]);
    const onLoadingCompleteRef = (0, _react.useRef)(onLoadingComplete);
    (0, _react.useEffect)(()=>{
        onLoadingCompleteRef.current = onLoadingComplete;
    }, [
        onLoadingComplete
    ]);
    const [blurComplete, setBlurComplete] = (0, _react.useState)(false);
    const [showAltText, setShowAltText] = (0, _react.useState)(false);
    const { props: imgAttributes, meta: imgMeta } = (0, _getimgprops.getImgProps)(props, {
        defaultLoader: _imageloader.default,
        imgConf: config,
        blurComplete,
        showAltText
    });
    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
            /*#__PURE__*/ (0, _jsxruntime.jsx)(ImageElement, {
                ...imgAttributes,
                unoptimized: imgMeta.unoptimized,
                placeholder: imgMeta.placeholder,
                fill: imgMeta.fill,
                onLoadRef: onLoadRef,
                onLoadingCompleteRef: onLoadingCompleteRef,
                setBlurComplete: setBlurComplete,
                setShowAltText: setShowAltText,
                sizesInput: props.sizes,
                ref: forwardedRef
            }),
            imgMeta.preload ? /*#__PURE__*/ (0, _jsxruntime.jsx)(ImagePreload, {
                isAppRouter: isAppRouter,
                imgAttributes: imgAttributes
            }) : null
        ]
    });
});
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=image-component.js.map
}),
"[project]/node_modules/next/dist/shared/lib/image-external.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    default: null,
    getImageProps: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return _default;
    },
    getImageProps: function() {
        return getImageProps;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-ssr] (ecmascript)");
const _getimgprops = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/get-img-props.js [app-ssr] (ecmascript)");
const _imagecomponent = __turbopack_context__.r("[project]/node_modules/next/dist/client/image-component.js [app-ssr] (ecmascript)");
const _imageloader = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-loader.js [app-ssr] (ecmascript)"));
function getImageProps(imgProps) {
    const { props } = (0, _getimgprops.getImgProps)(imgProps, {
        defaultLoader: _imageloader.default,
        // This is replaced by webpack define plugin
        imgConf: ("TURBOPACK compile-time value", {
            "deviceSizes": ("TURBOPACK compile-time value", [
                ("TURBOPACK compile-time value", 640),
                ("TURBOPACK compile-time value", 750),
                ("TURBOPACK compile-time value", 828),
                ("TURBOPACK compile-time value", 1080),
                ("TURBOPACK compile-time value", 1200),
                ("TURBOPACK compile-time value", 1920),
                ("TURBOPACK compile-time value", 2048),
                ("TURBOPACK compile-time value", 3840)
            ]),
            "imageSizes": ("TURBOPACK compile-time value", [
                ("TURBOPACK compile-time value", 32),
                ("TURBOPACK compile-time value", 48),
                ("TURBOPACK compile-time value", 64),
                ("TURBOPACK compile-time value", 96),
                ("TURBOPACK compile-time value", 128),
                ("TURBOPACK compile-time value", 256),
                ("TURBOPACK compile-time value", 384)
            ]),
            "qualities": ("TURBOPACK compile-time value", [
                ("TURBOPACK compile-time value", 75)
            ]),
            "path": ("TURBOPACK compile-time value", "/_next/image"),
            "loader": ("TURBOPACK compile-time value", "default"),
            "dangerouslyAllowSVG": ("TURBOPACK compile-time value", false),
            "unoptimized": ("TURBOPACK compile-time value", false),
            "domains": ("TURBOPACK compile-time value", []),
            "remotePatterns": ("TURBOPACK compile-time value", []),
            "localPatterns": ("TURBOPACK compile-time value", [
                ("TURBOPACK compile-time value", {
                    "pathname": ("TURBOPACK compile-time value", "**"),
                    "search": ("TURBOPACK compile-time value", "")
                })
            ])
        })
    });
    // Normally we don't care about undefined props because we pass to JSX,
    // but this exported function could be used by the end user for anything
    // so we delete undefined props to clean it up a little.
    for (const [key, value] of Object.entries(props)){
        if (value === undefined) {
            delete props[key];
        }
    }
    return {
        props
    };
}
const _default = _imagecomponent.Image; //# sourceMappingURL=image-external.js.map
}),
"[project]/node_modules/next/image.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-external.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/exifr/dist/full.esm.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Exifr",
    ()=>te,
    "Options",
    ()=>q,
    "allFormatters",
    ()=>X,
    "chunkedProps",
    ()=>G,
    "createDictionary",
    ()=>U,
    "default",
    ()=>__TURBOPACK__default__export__,
    "extendDictionary",
    ()=>F,
    "fetchUrlAsArrayBuffer",
    ()=>M,
    "fileParsers",
    ()=>w,
    "fileReaders",
    ()=>A,
    "gps",
    ()=>Se,
    "gpsOnlyOptions",
    ()=>me,
    "inheritables",
    ()=>K,
    "orientation",
    ()=>Pe,
    "orientationOnlyOptions",
    ()=>Ie,
    "otherSegments",
    ()=>V,
    "parse",
    ()=>ie,
    "readBlobAsArrayBuffer",
    ()=>R,
    "rotateCanvas",
    ()=>we,
    "rotateCss",
    ()=>Te,
    "rotation",
    ()=>Ae,
    "rotations",
    ()=>ke,
    "segmentParsers",
    ()=>T,
    "segments",
    ()=>z,
    "segmentsAndBlocks",
    ()=>j,
    "sidecar",
    ()=>st,
    "tagKeys",
    ()=>E,
    "tagRevivers",
    ()=>N,
    "tagValues",
    ()=>B,
    "thumbnail",
    ()=>ye,
    "thumbnailOnlyOptions",
    ()=>Ce,
    "thumbnailUrl",
    ()=>be,
    "tiffBlocks",
    ()=>H,
    "tiffExtractables",
    ()=>W
]);
var e = "undefined" != typeof self ? self : /*TURBOPACK member replacement*/ __turbopack_context__.g;
const t = "undefined" != typeof navigator, i = t && "undefined" == typeof HTMLImageElement, n = !("undefined" == ("TURBOPACK compile-time value", "object") || "undefined" == typeof process || !process.versions || !process.versions.node), s = e.Buffer, r = e.BigInt, a = !!s, o = (e)=>e;
function l(e, t = o) {
    if (n) try {
        return ("TURBOPACK compile-time truthy", 1) ? Promise.resolve(t((()=>{
            const e = new Error("Cannot find module as expression is too dynamic");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
        })())) : "TURBOPACK unreachable";
    } catch (t) {
        console.warn(`Couldn't load ${e}`);
    }
}
let h = e.fetch;
const u = (e)=>h = e;
if (!e.fetch) {
    const e = l("http", (e)=>e), t = l("https", (e)=>e), i = (n, { headers: s } = {})=>new Promise(async (r, a)=>{
            let { port: o, hostname: l, pathname: h, protocol: u, search: c } = new URL(n);
            const f = {
                method: "GET",
                hostname: l,
                path: encodeURI(h) + c,
                headers: s
            };
            "" !== o && (f.port = Number(o));
            const d = ("https:" === u ? await t : await e).request(f, (e)=>{
                if (301 === e.statusCode || 302 === e.statusCode) {
                    let t = new URL(e.headers.location, n).toString();
                    return i(t, {
                        headers: s
                    }).then(r).catch(a);
                }
                r({
                    status: e.statusCode,
                    arrayBuffer: ()=>new Promise((t)=>{
                            let i = [];
                            e.on("data", (e)=>i.push(e)), e.on("end", ()=>t(Buffer.concat(i)));
                        })
                });
            });
            d.on("error", a), d.end();
        });
    u(i);
}
function c(e, t, i) {
    return t in e ? Object.defineProperty(e, t, {
        value: i,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = i, e;
}
const f = (e)=>p(e) ? void 0 : e, d = (e)=>void 0 !== e;
function p(e) {
    return void 0 === e || (e instanceof Map ? 0 === e.size : 0 === Object.values(e).filter(d).length);
}
function g(e) {
    let t = new Error(e);
    throw delete t.stack, t;
}
function m(e) {
    return "" === (e = (function(e) {
        for(; e.endsWith("\0");)e = e.slice(0, -1);
        return e;
    })(e).trim()) ? void 0 : e;
}
function S(e) {
    let t = function(e) {
        let t = 0;
        return e.ifd0.enabled && (t += 1024), e.exif.enabled && (t += 2048), e.makerNote && (t += 2048), e.userComment && (t += 1024), e.gps.enabled && (t += 512), e.interop.enabled && (t += 100), e.ifd1.enabled && (t += 1024), t + 2048;
    }(e);
    return e.jfif.enabled && (t += 50), e.xmp.enabled && (t += 2e4), e.iptc.enabled && (t += 14e3), e.icc.enabled && (t += 6e3), t;
}
const C = (e)=>String.fromCharCode.apply(null, e), y = "undefined" != typeof TextDecoder ? new TextDecoder("utf-8") : void 0;
function b(e) {
    return y ? y.decode(e) : a ? Buffer.from(e).toString("utf8") : decodeURIComponent(escape(C(e)));
}
class I {
    static from(e, t) {
        return e instanceof this && e.le === t ? e : new I(e, void 0, void 0, t);
    }
    constructor(e, t = 0, i, n){
        if ("boolean" == typeof n && (this.le = n), Array.isArray(e) && (e = new Uint8Array(e)), 0 === e) this.byteOffset = 0, this.byteLength = 0;
        else if (e instanceof ArrayBuffer) {
            void 0 === i && (i = e.byteLength - t);
            let n = new DataView(e, t, i);
            this._swapDataView(n);
        } else if (e instanceof Uint8Array || e instanceof DataView || e instanceof I) {
            void 0 === i && (i = e.byteLength - t), (t += e.byteOffset) + i > e.byteOffset + e.byteLength && g("Creating view outside of available memory in ArrayBuffer");
            let n = new DataView(e.buffer, t, i);
            this._swapDataView(n);
        } else if ("number" == typeof e) {
            let t = new DataView(new ArrayBuffer(e));
            this._swapDataView(t);
        } else g("Invalid input argument for BufferView: " + e);
    }
    _swapArrayBuffer(e) {
        this._swapDataView(new DataView(e));
    }
    _swapBuffer(e) {
        this._swapDataView(new DataView(e.buffer, e.byteOffset, e.byteLength));
    }
    _swapDataView(e) {
        this.dataView = e, this.buffer = e.buffer, this.byteOffset = e.byteOffset, this.byteLength = e.byteLength;
    }
    _lengthToEnd(e) {
        return this.byteLength - e;
    }
    set(e, t, i = I) {
        return e instanceof DataView || e instanceof I ? e = new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : e instanceof ArrayBuffer && (e = new Uint8Array(e)), e instanceof Uint8Array || g("BufferView.set(): Invalid data argument."), this.toUint8().set(e, t), new i(this, t, e.byteLength);
    }
    subarray(e, t) {
        return t = t || this._lengthToEnd(e), new I(this, e, t);
    }
    toUint8() {
        return new Uint8Array(this.buffer, this.byteOffset, this.byteLength);
    }
    getUint8Array(e, t) {
        return new Uint8Array(this.buffer, this.byteOffset + e, t);
    }
    getString(e = 0, t = this.byteLength) {
        return b(this.getUint8Array(e, t));
    }
    getLatin1String(e = 0, t = this.byteLength) {
        let i = this.getUint8Array(e, t);
        return C(i);
    }
    getUnicodeString(e = 0, t = this.byteLength) {
        const i = [];
        for(let n = 0; n < t && e + n < this.byteLength; n += 2)i.push(this.getUint16(e + n));
        return C(i);
    }
    getInt8(e) {
        return this.dataView.getInt8(e);
    }
    getUint8(e) {
        return this.dataView.getUint8(e);
    }
    getInt16(e, t = this.le) {
        return this.dataView.getInt16(e, t);
    }
    getInt32(e, t = this.le) {
        return this.dataView.getInt32(e, t);
    }
    getUint16(e, t = this.le) {
        return this.dataView.getUint16(e, t);
    }
    getUint32(e, t = this.le) {
        return this.dataView.getUint32(e, t);
    }
    getFloat32(e, t = this.le) {
        return this.dataView.getFloat32(e, t);
    }
    getFloat64(e, t = this.le) {
        return this.dataView.getFloat64(e, t);
    }
    getFloat(e, t = this.le) {
        return this.dataView.getFloat32(e, t);
    }
    getDouble(e, t = this.le) {
        return this.dataView.getFloat64(e, t);
    }
    getUintBytes(e, t, i) {
        switch(t){
            case 1:
                return this.getUint8(e, i);
            case 2:
                return this.getUint16(e, i);
            case 4:
                return this.getUint32(e, i);
            case 8:
                return this.getUint64 && this.getUint64(e, i);
        }
    }
    getUint(e, t, i) {
        switch(t){
            case 8:
                return this.getUint8(e, i);
            case 16:
                return this.getUint16(e, i);
            case 32:
                return this.getUint32(e, i);
            case 64:
                return this.getUint64 && this.getUint64(e, i);
        }
    }
    toString(e) {
        return this.dataView.toString(e, this.constructor.name);
    }
    ensureChunk() {}
}
function P(e, t) {
    g(`${e} '${t}' was not loaded, try using full build of exifr.`);
}
class k extends Map {
    constructor(e){
        super(), this.kind = e;
    }
    get(e, t) {
        return this.has(e) || P(this.kind, e), t && (e in t || function(e, t) {
            g(`Unknown ${e} '${t}'.`);
        }(this.kind, e), t[e].enabled || P(this.kind, e)), super.get(e);
    }
    keyList() {
        return Array.from(this.keys());
    }
}
var w = new k("file parser"), T = new k("segment parser"), A = new k("file reader");
function D(e, n) {
    return "string" == typeof e ? O(e, n) : t && !i && e instanceof HTMLImageElement ? O(e.src, n) : e instanceof Uint8Array || e instanceof ArrayBuffer || e instanceof DataView ? new I(e) : t && e instanceof Blob ? x(e, n, "blob", R) : void g("Invalid input argument");
}
function O(e, i) {
    return (s = e).startsWith("data:") || s.length > 1e4 ? v(e, i, "base64") : n && e.includes("://") ? x(e, i, "url", M) : n ? v(e, i, "fs") : t ? x(e, i, "url", M) : void g("Invalid input argument");
    //TURBOPACK unreachable
    ;
    var s;
}
async function x(e, t, i, n) {
    return A.has(i) ? v(e, t, i) : n ? async function(e, t) {
        let i = await t(e);
        return new I(i);
    }(e, n) : void g(`Parser ${i} is not loaded`);
}
async function v(e, t, i) {
    let n = new (A.get(i))(e, t);
    return await n.read(), n;
}
const M = (e)=>h(e).then((e)=>e.arrayBuffer()), R = (e)=>new Promise((t, i)=>{
        let n = new FileReader;
        n.onloadend = ()=>t(n.result || new ArrayBuffer), n.onerror = i, n.readAsArrayBuffer(e);
    });
class L extends Map {
    get tagKeys() {
        return this.allKeys || (this.allKeys = Array.from(this.keys())), this.allKeys;
    }
    get tagValues() {
        return this.allValues || (this.allValues = Array.from(this.values())), this.allValues;
    }
}
function U(e, t, i) {
    let n = new L;
    for (let [e, t] of i)n.set(e, t);
    if (Array.isArray(t)) for (let i of t)e.set(i, n);
    else e.set(t, n);
    return n;
}
function F(e, t, i) {
    let n, s = e.get(t);
    for (n of i)s.set(n[0], n[1]);
}
const E = new Map, B = new Map, N = new Map, G = [
    "chunked",
    "firstChunkSize",
    "firstChunkSizeNode",
    "firstChunkSizeBrowser",
    "chunkSize",
    "chunkLimit"
], V = [
    "jfif",
    "xmp",
    "icc",
    "iptc",
    "ihdr"
], z = [
    "tiff",
    ...V
], H = [
    "ifd0",
    "ifd1",
    "exif",
    "gps",
    "interop"
], j = [
    ...z,
    ...H
], W = [
    "makerNote",
    "userComment"
], K = [
    "translateKeys",
    "translateValues",
    "reviveValues",
    "multiSegment"
], X = [
    ...K,
    "sanitize",
    "mergeOutput",
    "silentErrors"
];
class _ {
    get translate() {
        return this.translateKeys || this.translateValues || this.reviveValues;
    }
}
class Y extends _ {
    get needed() {
        return this.enabled || this.deps.size > 0;
    }
    constructor(e, t, i, n){
        if (super(), c(this, "enabled", !1), c(this, "skip", new Set), c(this, "pick", new Set), c(this, "deps", new Set), c(this, "translateKeys", !1), c(this, "translateValues", !1), c(this, "reviveValues", !1), this.key = e, this.enabled = t, this.parse = this.enabled, this.applyInheritables(n), this.canBeFiltered = H.includes(e), this.canBeFiltered && (this.dict = E.get(e)), void 0 !== i) if (Array.isArray(i)) this.parse = this.enabled = !0, this.canBeFiltered && i.length > 0 && this.translateTagSet(i, this.pick);
        else if ("object" == typeof i) {
            if (this.enabled = !0, this.parse = !1 !== i.parse, this.canBeFiltered) {
                let { pick: e, skip: t } = i;
                e && e.length > 0 && this.translateTagSet(e, this.pick), t && t.length > 0 && this.translateTagSet(t, this.skip);
            }
            this.applyInheritables(i);
        } else !0 === i || !1 === i ? this.parse = this.enabled = i : g(`Invalid options argument: ${i}`);
    }
    applyInheritables(e) {
        let t, i;
        for (t of K)i = e[t], void 0 !== i && (this[t] = i);
    }
    translateTagSet(e, t) {
        if (this.dict) {
            let i, n, { tagKeys: s, tagValues: r } = this.dict;
            for (i of e)"string" == typeof i ? (n = r.indexOf(i), -1 === n && (n = s.indexOf(Number(i))), -1 !== n && t.add(Number(s[n]))) : t.add(i);
        } else for (let i of e)t.add(i);
    }
    finalizeFilters() {
        !this.enabled && this.deps.size > 0 ? (this.enabled = !0, ee(this.pick, this.deps)) : this.enabled && this.pick.size > 0 && ee(this.pick, this.deps);
    }
}
var $ = {
    jfif: !1,
    tiff: !0,
    xmp: !1,
    icc: !1,
    iptc: !1,
    ifd0: !0,
    ifd1: !1,
    exif: !0,
    gps: !0,
    interop: !1,
    ihdr: void 0,
    makerNote: !1,
    userComment: !1,
    multiSegment: !1,
    skip: [],
    pick: [],
    translateKeys: !0,
    translateValues: !0,
    reviveValues: !0,
    sanitize: !0,
    mergeOutput: !0,
    silentErrors: !0,
    chunked: !0,
    firstChunkSize: void 0,
    firstChunkSizeNode: 512,
    firstChunkSizeBrowser: 65536,
    chunkSize: 65536,
    chunkLimit: 5
}, J = new Map;
class q extends _ {
    static useCached(e) {
        let t = J.get(e);
        return void 0 !== t || (t = new this(e), J.set(e, t)), t;
    }
    constructor(e){
        super(), !0 === e ? this.setupFromTrue() : void 0 === e ? this.setupFromUndefined() : Array.isArray(e) ? this.setupFromArray(e) : "object" == typeof e ? this.setupFromObject(e) : g(`Invalid options argument ${e}`), void 0 === this.firstChunkSize && (this.firstChunkSize = t ? this.firstChunkSizeBrowser : this.firstChunkSizeNode), this.mergeOutput && (this.ifd1.enabled = !1), this.filterNestedSegmentTags(), this.traverseTiffDependencyTree(), this.checkLoadedPlugins();
    }
    setupFromUndefined() {
        let e;
        for (e of G)this[e] = $[e];
        for (e of X)this[e] = $[e];
        for (e of W)this[e] = $[e];
        for (e of j)this[e] = new Y(e, $[e], void 0, this);
    }
    setupFromTrue() {
        let e;
        for (e of G)this[e] = $[e];
        for (e of X)this[e] = $[e];
        for (e of W)this[e] = !0;
        for (e of j)this[e] = new Y(e, !0, void 0, this);
    }
    setupFromArray(e) {
        let t;
        for (t of G)this[t] = $[t];
        for (t of X)this[t] = $[t];
        for (t of W)this[t] = $[t];
        for (t of j)this[t] = new Y(t, !1, void 0, this);
        this.setupGlobalFilters(e, void 0, H);
    }
    setupFromObject(e) {
        let t;
        for (t of (H.ifd0 = H.ifd0 || H.image, H.ifd1 = H.ifd1 || H.thumbnail, Object.assign(this, e), G))this[t] = Z(e[t], $[t]);
        for (t of X)this[t] = Z(e[t], $[t]);
        for (t of W)this[t] = Z(e[t], $[t]);
        for (t of z)this[t] = new Y(t, $[t], e[t], this);
        for (t of H)this[t] = new Y(t, $[t], e[t], this.tiff);
        this.setupGlobalFilters(e.pick, e.skip, H, j), !0 === e.tiff ? this.batchEnableWithBool(H, !0) : !1 === e.tiff ? this.batchEnableWithUserValue(H, e) : Array.isArray(e.tiff) ? this.setupGlobalFilters(e.tiff, void 0, H) : "object" == typeof e.tiff && this.setupGlobalFilters(e.tiff.pick, e.tiff.skip, H);
    }
    batchEnableWithBool(e, t) {
        for (let i of e)this[i].enabled = t;
    }
    batchEnableWithUserValue(e, t) {
        for (let i of e){
            let e = t[i];
            this[i].enabled = !1 !== e && void 0 !== e;
        }
    }
    setupGlobalFilters(e, t, i, n = i) {
        if (e && e.length) {
            for (let e of n)this[e].enabled = !1;
            let t = Q(e, i);
            for (let [e, i] of t)ee(this[e].pick, i), this[e].enabled = !0;
        } else if (t && t.length) {
            let e = Q(t, i);
            for (let [t, i] of e)ee(this[t].skip, i);
        }
    }
    filterNestedSegmentTags() {
        let { ifd0: e, exif: t, xmp: i, iptc: n, icc: s } = this;
        this.makerNote ? t.deps.add(37500) : t.skip.add(37500), this.userComment ? t.deps.add(37510) : t.skip.add(37510), i.enabled || e.skip.add(700), n.enabled || e.skip.add(33723), s.enabled || e.skip.add(34675);
    }
    traverseTiffDependencyTree() {
        let { ifd0: e, exif: t, gps: i, interop: n } = this;
        n.needed && (t.deps.add(40965), e.deps.add(40965)), t.needed && e.deps.add(34665), i.needed && e.deps.add(34853), this.tiff.enabled = H.some((e)=>!0 === this[e].enabled) || this.makerNote || this.userComment;
        for (let e of H)this[e].finalizeFilters();
    }
    get onlyTiff() {
        return !V.map((e)=>this[e].enabled).some((e)=>!0 === e) && this.tiff.enabled;
    }
    checkLoadedPlugins() {
        for (let e of z)this[e].enabled && !T.has(e) && P("segment parser", e);
    }
}
function Q(e, t) {
    let i, n, s, r, a = [];
    for (s of t){
        for (r of (i = E.get(s), n = [], i))(e.includes(r[0]) || e.includes(r[1])) && n.push(r[0]);
        n.length && a.push([
            s,
            n
        ]);
    }
    return a;
}
function Z(e, t) {
    return void 0 !== e ? e : void 0 !== t ? t : void 0;
}
function ee(e, t) {
    for (let i of t)e.add(i);
}
c(q, "default", $);
class te {
    constructor(e){
        c(this, "parsers", {}), c(this, "output", {}), c(this, "errors", []), c(this, "pushToErrors", (e)=>this.errors.push(e)), this.options = q.useCached(e);
    }
    async read(e) {
        this.file = await D(e, this.options);
    }
    setup() {
        if (this.fileParser) return;
        let { file: e } = this, t = e.getUint16(0);
        for (let [i, n] of w)if (n.canHandle(e, t)) return this.fileParser = new n(this.options, this.file, this.parsers), e[i] = !0;
        this.file.close && this.file.close(), g("Unknown file format");
    }
    async parse() {
        let { output: e, errors: t } = this;
        return this.setup(), this.options.silentErrors ? (await this.executeParsers().catch(this.pushToErrors), t.push(...this.fileParser.errors)) : await this.executeParsers(), this.file.close && this.file.close(), this.options.silentErrors && t.length > 0 && (e.errors = t), f(e);
    }
    async executeParsers() {
        let { output: e } = this;
        await this.fileParser.parse();
        let t = Object.values(this.parsers).map(async (t)=>{
            let i = await t.parse();
            t.assignToOutput(e, i);
        });
        this.options.silentErrors && (t = t.map((e)=>e.catch(this.pushToErrors))), await Promise.all(t);
    }
    async extractThumbnail() {
        this.setup();
        let { options: e, file: t } = this, i = T.get("tiff", e);
        var n;
        if (t.tiff ? n = {
            start: 0,
            type: "tiff"
        } : t.jpeg && (n = await this.fileParser.getOrFindSegment("tiff")), void 0 === n) return;
        let s = await this.fileParser.ensureSegmentChunk(n), r = this.parsers.tiff = new i(s, e, t), a = await r.extractThumbnail();
        return t.close && t.close(), a;
    }
}
async function ie(e, t) {
    let i = new te(t);
    return await i.read(e), i.parse();
}
var ne = Object.freeze({
    __proto__: null,
    parse: ie,
    Exifr: te,
    fileParsers: w,
    segmentParsers: T,
    fileReaders: A,
    tagKeys: E,
    tagValues: B,
    tagRevivers: N,
    createDictionary: U,
    extendDictionary: F,
    fetchUrlAsArrayBuffer: M,
    readBlobAsArrayBuffer: R,
    chunkedProps: G,
    otherSegments: V,
    segments: z,
    tiffBlocks: H,
    segmentsAndBlocks: j,
    tiffExtractables: W,
    inheritables: K,
    allFormatters: X,
    Options: q
});
class se {
    constructor(e, t, i){
        c(this, "errors", []), c(this, "ensureSegmentChunk", async (e)=>{
            let t = e.start, i = e.size || 65536;
            if (this.file.chunked) if (this.file.available(t, i)) e.chunk = this.file.subarray(t, i);
            else try {
                e.chunk = await this.file.readChunk(t, i);
            } catch (t) {
                g(`Couldn't read segment: ${JSON.stringify(e)}. ${t.message}`);
            }
            else this.file.byteLength > t + i ? e.chunk = this.file.subarray(t, i) : void 0 === e.size ? e.chunk = this.file.subarray(t) : g("Segment unreachable: " + JSON.stringify(e));
            return e.chunk;
        }), this.extendOptions && this.extendOptions(e), this.options = e, this.file = t, this.parsers = i;
    }
    injectSegment(e, t) {
        this.options[e].enabled && this.createParser(e, t);
    }
    createParser(e, t) {
        let i = new (T.get(e))(t, this.options, this.file);
        return this.parsers[e] = i;
    }
    createParsers(e) {
        for (let t of e){
            let { type: e, chunk: i } = t, n = this.options[e];
            if (n && n.enabled) {
                let t = this.parsers[e];
                t && t.append || t || this.createParser(e, i);
            }
        }
    }
    async readSegments(e) {
        let t = e.map(this.ensureSegmentChunk);
        await Promise.all(t);
    }
}
class re {
    static findPosition(e, t) {
        let i = e.getUint16(t + 2) + 2, n = "function" == typeof this.headerLength ? this.headerLength(e, t, i) : this.headerLength, s = t + n, r = i - n;
        return {
            offset: t,
            length: i,
            headerLength: n,
            start: s,
            size: r,
            end: s + r
        };
    }
    static parse(e, t = {}) {
        return new this(e, new q({
            [this.type]: t
        }), e).parse();
    }
    normalizeInput(e) {
        return e instanceof I ? e : new I(e);
    }
    constructor(e, t = {}, i){
        c(this, "errors", []), c(this, "raw", new Map), c(this, "handleError", (e)=>{
            if (!this.options.silentErrors) throw e;
            this.errors.push(e.message);
        }), this.chunk = this.normalizeInput(e), this.file = i, this.type = this.constructor.type, this.globalOptions = this.options = t, this.localOptions = t[this.type], this.canTranslate = this.localOptions && this.localOptions.translate;
    }
    translate() {
        this.canTranslate && (this.translated = this.translateBlock(this.raw, this.type));
    }
    get output() {
        return this.translated ? this.translated : this.raw ? Object.fromEntries(this.raw) : void 0;
    }
    translateBlock(e, t) {
        let i = N.get(t), n = B.get(t), s = E.get(t), r = this.options[t], a = r.reviveValues && !!i, o = r.translateValues && !!n, l = r.translateKeys && !!s, h = {};
        for (let [t, r] of e)a && i.has(t) ? r = i.get(t)(r) : o && n.has(t) && (r = this.translateValue(r, n.get(t))), l && s.has(t) && (t = s.get(t) || t), h[t] = r;
        return h;
    }
    translateValue(e, t) {
        return t[e] || t.DEFAULT || e;
    }
    assignToOutput(e, t) {
        this.assignObjectToOutput(e, this.constructor.type, t);
    }
    assignObjectToOutput(e, t, i) {
        if (this.globalOptions.mergeOutput) return Object.assign(e, i);
        e[t] ? Object.assign(e[t], i) : e[t] = i;
    }
}
c(re, "headerLength", 4), c(re, "type", void 0), c(re, "multiSegment", !1), c(re, "canHandle", ()=>!1);
function ae(e) {
    return 192 === e || 194 === e || 196 === e || 219 === e || 221 === e || 218 === e || 254 === e;
}
function oe(e) {
    return e >= 224 && e <= 239;
}
function le(e, t, i) {
    for (let [n, s] of T)if (s.canHandle(e, t, i)) return n;
}
class he extends se {
    constructor(...e){
        super(...e), c(this, "appSegments", []), c(this, "jpegSegments", []), c(this, "unknownSegments", []);
    }
    static canHandle(e, t) {
        return 65496 === t;
    }
    async parse() {
        await this.findAppSegments(), await this.readSegments(this.appSegments), this.mergeMultiSegments(), this.createParsers(this.mergedAppSegments || this.appSegments);
    }
    setupSegmentFinderArgs(e) {
        !0 === e ? (this.findAll = !0, this.wanted = new Set(T.keyList())) : (e = void 0 === e ? T.keyList().filter((e)=>this.options[e].enabled) : e.filter((e)=>this.options[e].enabled && T.has(e)), this.findAll = !1, this.remaining = new Set(e), this.wanted = new Set(e)), this.unfinishedMultiSegment = !1;
    }
    async findAppSegments(e = 0, t) {
        this.setupSegmentFinderArgs(t);
        let { file: i, findAll: n, wanted: s, remaining: r } = this;
        if (!n && this.file.chunked && (n = Array.from(s).some((e)=>{
            let t = T.get(e), i = this.options[e];
            return t.multiSegment && i.multiSegment;
        }), n && await this.file.readWhole()), e = this.findAppSegmentsInRange(e, i.byteLength), !this.options.onlyTiff && i.chunked) {
            let t = !1;
            for(; r.size > 0 && !t && (i.canReadNextChunk || this.unfinishedMultiSegment);){
                let { nextChunkOffset: n } = i, s = this.appSegments.some((e)=>!this.file.available(e.offset || e.start, e.length || e.size));
                if (t = e > n && !s ? !await i.readNextChunk(e) : !await i.readNextChunk(n), void 0 === (e = this.findAppSegmentsInRange(e, i.byteLength))) return;
            }
        }
    }
    findAppSegmentsInRange(e, t) {
        t -= 2;
        let i, n, s, r, a, o, { file: l, findAll: h, wanted: u, remaining: c, options: f } = this;
        for(; e < t; e++)if (255 === l.getUint8(e)) {
            if (i = l.getUint8(e + 1), oe(i)) {
                if (n = l.getUint16(e + 2), s = le(l, e, n), s && u.has(s) && (r = T.get(s), a = r.findPosition(l, e), o = f[s], a.type = s, this.appSegments.push(a), !h && (r.multiSegment && o.multiSegment ? (this.unfinishedMultiSegment = a.chunkNumber < a.chunkCount, this.unfinishedMultiSegment || c.delete(s)) : c.delete(s), 0 === c.size))) break;
                f.recordUnknownSegments && (a = re.findPosition(l, e), a.marker = i, this.unknownSegments.push(a)), e += n + 1;
            } else if (ae(i)) {
                if (n = l.getUint16(e + 2), 218 === i && !1 !== f.stopAfterSos) return;
                f.recordJpegSegments && this.jpegSegments.push({
                    offset: e,
                    length: n,
                    marker: i
                }), e += n + 1;
            }
        }
        return e;
    }
    mergeMultiSegments() {
        if (!this.appSegments.some((e)=>e.multiSegment)) return;
        let e = function(e, t) {
            let i, n, s, r = new Map;
            for(let a = 0; a < e.length; a++)i = e[a], n = i[t], r.has(n) ? s = r.get(n) : r.set(n, s = []), s.push(i);
            return Array.from(r);
        }(this.appSegments, "type");
        this.mergedAppSegments = e.map(([e, t])=>{
            let i = T.get(e, this.options);
            if (i.handleMultiSegments) {
                return {
                    type: e,
                    chunk: i.handleMultiSegments(t)
                };
            }
            return t[0];
        });
    }
    getSegment(e) {
        return this.appSegments.find((t)=>t.type === e);
    }
    async getOrFindSegment(e) {
        let t = this.getSegment(e);
        return void 0 === t && (await this.findAppSegments(0, [
            e
        ]), t = this.getSegment(e)), t;
    }
}
c(he, "type", "jpeg"), w.set("jpeg", he);
const ue = [
    void 0,
    1,
    1,
    2,
    4,
    8,
    1,
    1,
    2,
    4,
    8,
    4,
    8,
    4
];
class ce extends re {
    parseHeader() {
        var e = this.chunk.getUint16();
        18761 === e ? this.le = !0 : 19789 === e && (this.le = !1), this.chunk.le = this.le, this.headerParsed = !0;
    }
    parseTags(e, t, i = new Map) {
        let { pick: n, skip: s } = this.options[t];
        n = new Set(n);
        let r = n.size > 0, a = 0 === s.size, o = this.chunk.getUint16(e);
        e += 2;
        for(let l = 0; l < o; l++){
            let o = this.chunk.getUint16(e);
            if (r) {
                if (n.has(o) && (i.set(o, this.parseTag(e, o, t)), n.delete(o), 0 === n.size)) break;
            } else !a && s.has(o) || i.set(o, this.parseTag(e, o, t));
            e += 12;
        }
        return i;
    }
    parseTag(e, t, i) {
        let { chunk: n } = this, s = n.getUint16(e + 2), r = n.getUint32(e + 4), a = ue[s];
        if (a * r <= 4 ? e += 8 : e = n.getUint32(e + 8), (s < 1 || s > 13) && g(`Invalid TIFF value type. block: ${i.toUpperCase()}, tag: ${t.toString(16)}, type: ${s}, offset ${e}`), e > n.byteLength && g(`Invalid TIFF value offset. block: ${i.toUpperCase()}, tag: ${t.toString(16)}, type: ${s}, offset ${e} is outside of chunk size ${n.byteLength}`), 1 === s) return n.getUint8Array(e, r);
        if (2 === s) return m(n.getString(e, r));
        if (7 === s) return n.getUint8Array(e, r);
        if (1 === r) return this.parseTagValue(s, e);
        {
            let t = new (function(e) {
                switch(e){
                    case 1:
                        return Uint8Array;
                    case 3:
                        return Uint16Array;
                    case 4:
                        return Uint32Array;
                    case 5:
                        return Array;
                    case 6:
                        return Int8Array;
                    case 8:
                        return Int16Array;
                    case 9:
                        return Int32Array;
                    case 10:
                        return Array;
                    case 11:
                        return Float32Array;
                    case 12:
                        return Float64Array;
                    default:
                        return Array;
                }
            }(s))(r), i = a;
            for(let n = 0; n < r; n++)t[n] = this.parseTagValue(s, e), e += i;
            return t;
        }
    }
    parseTagValue(e, t) {
        let { chunk: i } = this;
        switch(e){
            case 1:
                return i.getUint8(t);
            case 3:
                return i.getUint16(t);
            case 4:
                return i.getUint32(t);
            case 5:
                return i.getUint32(t) / i.getUint32(t + 4);
            case 6:
                return i.getInt8(t);
            case 8:
                return i.getInt16(t);
            case 9:
                return i.getInt32(t);
            case 10:
                return i.getInt32(t) / i.getInt32(t + 4);
            case 11:
                return i.getFloat(t);
            case 12:
                return i.getDouble(t);
            case 13:
                return i.getUint32(t);
            default:
                g(`Invalid tiff type ${e}`);
        }
    }
}
class fe extends ce {
    static canHandle(e, t) {
        return 225 === e.getUint8(t + 1) && 1165519206 === e.getUint32(t + 4) && 0 === e.getUint16(t + 8);
    }
    async parse() {
        this.parseHeader();
        let { options: e } = this;
        return e.ifd0.enabled && await this.parseIfd0Block(), e.exif.enabled && await this.safeParse("parseExifBlock"), e.gps.enabled && await this.safeParse("parseGpsBlock"), e.interop.enabled && await this.safeParse("parseInteropBlock"), e.ifd1.enabled && await this.safeParse("parseThumbnailBlock"), this.createOutput();
    }
    safeParse(e) {
        let t = this[e]();
        return void 0 !== t.catch && (t = t.catch(this.handleError)), t;
    }
    findIfd0Offset() {
        void 0 === this.ifd0Offset && (this.ifd0Offset = this.chunk.getUint32(4));
    }
    findIfd1Offset() {
        if (void 0 === this.ifd1Offset) {
            this.findIfd0Offset();
            let e = this.chunk.getUint16(this.ifd0Offset), t = this.ifd0Offset + 2 + 12 * e;
            this.ifd1Offset = this.chunk.getUint32(t);
        }
    }
    parseBlock(e, t) {
        let i = new Map;
        return this[t] = i, this.parseTags(e, t, i), i;
    }
    async parseIfd0Block() {
        if (this.ifd0) return;
        let { file: e } = this;
        this.findIfd0Offset(), this.ifd0Offset < 8 && g("Malformed EXIF data"), !e.chunked && this.ifd0Offset > e.byteLength && g(`IFD0 offset points to outside of file.\nthis.ifd0Offset: ${this.ifd0Offset}, file.byteLength: ${e.byteLength}`), e.tiff && await e.ensureChunk(this.ifd0Offset, S(this.options));
        let t = this.parseBlock(this.ifd0Offset, "ifd0");
        return 0 !== t.size ? (this.exifOffset = t.get(34665), this.interopOffset = t.get(40965), this.gpsOffset = t.get(34853), this.xmp = t.get(700), this.iptc = t.get(33723), this.icc = t.get(34675), this.options.sanitize && (t.delete(34665), t.delete(40965), t.delete(34853), t.delete(700), t.delete(33723), t.delete(34675)), t) : void 0;
    }
    async parseExifBlock() {
        if (this.exif) return;
        if (this.ifd0 || await this.parseIfd0Block(), void 0 === this.exifOffset) return;
        this.file.tiff && await this.file.ensureChunk(this.exifOffset, S(this.options));
        let e = this.parseBlock(this.exifOffset, "exif");
        return this.interopOffset || (this.interopOffset = e.get(40965)), this.makerNote = e.get(37500), this.userComment = e.get(37510), this.options.sanitize && (e.delete(40965), e.delete(37500), e.delete(37510)), this.unpack(e, 41728), this.unpack(e, 41729), e;
    }
    unpack(e, t) {
        let i = e.get(t);
        i && 1 === i.length && e.set(t, i[0]);
    }
    async parseGpsBlock() {
        if (this.gps) return;
        if (this.ifd0 || await this.parseIfd0Block(), void 0 === this.gpsOffset) return;
        let e = this.parseBlock(this.gpsOffset, "gps");
        return e && e.has(2) && e.has(4) && (e.set("latitude", de(...e.get(2), e.get(1))), e.set("longitude", de(...e.get(4), e.get(3)))), e;
    }
    async parseInteropBlock() {
        if (!this.interop && (this.ifd0 || await this.parseIfd0Block(), void 0 !== this.interopOffset || this.exif || await this.parseExifBlock(), void 0 !== this.interopOffset)) return this.parseBlock(this.interopOffset, "interop");
    }
    async parseThumbnailBlock(e = !1) {
        if (!this.ifd1 && !this.ifd1Parsed && (!this.options.mergeOutput || e)) return this.findIfd1Offset(), this.ifd1Offset > 0 && (this.parseBlock(this.ifd1Offset, "ifd1"), this.ifd1Parsed = !0), this.ifd1;
    }
    async extractThumbnail() {
        if (this.headerParsed || this.parseHeader(), this.ifd1Parsed || await this.parseThumbnailBlock(!0), void 0 === this.ifd1) return;
        let e = this.ifd1.get(513), t = this.ifd1.get(514);
        return this.chunk.getUint8Array(e, t);
    }
    get image() {
        return this.ifd0;
    }
    get thumbnail() {
        return this.ifd1;
    }
    createOutput() {
        let e, t, i, n = {};
        for (t of H)if (e = this[t], !p(e)) if (i = this.canTranslate ? this.translateBlock(e, t) : Object.fromEntries(e), this.options.mergeOutput) {
            if ("ifd1" === t) continue;
            Object.assign(n, i);
        } else n[t] = i;
        return this.makerNote && (n.makerNote = this.makerNote), this.userComment && (n.userComment = this.userComment), n;
    }
    assignToOutput(e, t) {
        if (this.globalOptions.mergeOutput) Object.assign(e, t);
        else for (let [i, n] of Object.entries(t))this.assignObjectToOutput(e, i, n);
    }
}
function de(e, t, i, n) {
    var s = e + t / 60 + i / 3600;
    return "S" !== n && "W" !== n || (s *= -1), s;
}
c(fe, "type", "tiff"), c(fe, "headerLength", 10), T.set("tiff", fe);
var pe = Object.freeze({
    __proto__: null,
    default: ne,
    Exifr: te,
    fileParsers: w,
    segmentParsers: T,
    fileReaders: A,
    tagKeys: E,
    tagValues: B,
    tagRevivers: N,
    createDictionary: U,
    extendDictionary: F,
    fetchUrlAsArrayBuffer: M,
    readBlobAsArrayBuffer: R,
    chunkedProps: G,
    otherSegments: V,
    segments: z,
    tiffBlocks: H,
    segmentsAndBlocks: j,
    tiffExtractables: W,
    inheritables: K,
    allFormatters: X,
    Options: q,
    parse: ie
});
const ge = {
    ifd0: !1,
    ifd1: !1,
    exif: !1,
    gps: !1,
    interop: !1,
    sanitize: !1,
    reviveValues: !0,
    translateKeys: !1,
    translateValues: !1,
    mergeOutput: !1
}, me = Object.assign({}, ge, {
    firstChunkSize: 4e4,
    gps: [
        1,
        2,
        3,
        4
    ]
});
async function Se(e) {
    let t = new te(me);
    await t.read(e);
    let i = await t.parse();
    if (i && i.gps) {
        let { latitude: e, longitude: t } = i.gps;
        return {
            latitude: e,
            longitude: t
        };
    }
}
const Ce = Object.assign({}, ge, {
    tiff: !1,
    ifd1: !0,
    mergeOutput: !1
});
async function ye(e) {
    let t = new te(Ce);
    await t.read(e);
    let i = await t.extractThumbnail();
    return i && a ? s.from(i) : i;
}
async function be(e) {
    let t = await this.thumbnail(e);
    if (void 0 !== t) {
        let e = new Blob([
            t
        ]);
        return URL.createObjectURL(e);
    }
}
const Ie = Object.assign({}, ge, {
    firstChunkSize: 4e4,
    ifd0: [
        274
    ]
});
async function Pe(e) {
    let t = new te(Ie);
    await t.read(e);
    let i = await t.parse();
    if (i && i.ifd0) return i.ifd0[274];
}
const ke = Object.freeze({
    1: {
        dimensionSwapped: !1,
        scaleX: 1,
        scaleY: 1,
        deg: 0,
        rad: 0
    },
    2: {
        dimensionSwapped: !1,
        scaleX: -1,
        scaleY: 1,
        deg: 0,
        rad: 0
    },
    3: {
        dimensionSwapped: !1,
        scaleX: 1,
        scaleY: 1,
        deg: 180,
        rad: 180 * Math.PI / 180
    },
    4: {
        dimensionSwapped: !1,
        scaleX: -1,
        scaleY: 1,
        deg: 180,
        rad: 180 * Math.PI / 180
    },
    5: {
        dimensionSwapped: !0,
        scaleX: 1,
        scaleY: -1,
        deg: 90,
        rad: 90 * Math.PI / 180
    },
    6: {
        dimensionSwapped: !0,
        scaleX: 1,
        scaleY: 1,
        deg: 90,
        rad: 90 * Math.PI / 180
    },
    7: {
        dimensionSwapped: !0,
        scaleX: 1,
        scaleY: -1,
        deg: 270,
        rad: 270 * Math.PI / 180
    },
    8: {
        dimensionSwapped: !0,
        scaleX: 1,
        scaleY: 1,
        deg: 270,
        rad: 270 * Math.PI / 180
    }
});
let we = !0, Te = !0;
if ("object" == typeof navigator) {
    let e = navigator.userAgent;
    if (e.includes("iPad") || e.includes("iPhone")) {
        let t = e.match(/OS (\d+)_(\d+)/);
        if (t) {
            let [, e, i] = t, n = Number(e) + .1 * Number(i);
            we = n < 13.4, Te = !1;
        }
    } else if (e.includes("OS X 10")) {
        let [, t] = e.match(/OS X 10[_.](\d+)/);
        we = Te = Number(t) < 15;
    }
    if (e.includes("Chrome/")) {
        let [, t] = e.match(/Chrome\/(\d+)/);
        we = Te = Number(t) < 81;
    } else if (e.includes("Firefox/")) {
        let [, t] = e.match(/Firefox\/(\d+)/);
        we = Te = Number(t) < 77;
    }
}
async function Ae(e) {
    let t = await Pe(e);
    return Object.assign({
        canvas: we,
        css: Te
    }, ke[t]);
}
class De extends I {
    constructor(...e){
        super(...e), c(this, "ranges", new Oe), 0 !== this.byteLength && this.ranges.add(0, this.byteLength);
    }
    _tryExtend(e, t, i) {
        if (0 === e && 0 === this.byteLength && i) {
            let e = new DataView(i.buffer || i, i.byteOffset, i.byteLength);
            this._swapDataView(e);
        } else {
            let i = e + t;
            if (i > this.byteLength) {
                let { dataView: e } = this._extend(i);
                this._swapDataView(e);
            }
        }
    }
    _extend(e) {
        let t;
        t = a ? s.allocUnsafe(e) : new Uint8Array(e);
        let i = new DataView(t.buffer, t.byteOffset, t.byteLength);
        return t.set(new Uint8Array(this.buffer, this.byteOffset, this.byteLength), 0), {
            uintView: t,
            dataView: i
        };
    }
    subarray(e, t, i = !1) {
        return t = t || this._lengthToEnd(e), i && this._tryExtend(e, t), this.ranges.add(e, t), super.subarray(e, t);
    }
    set(e, t, i = !1) {
        i && this._tryExtend(t, e.byteLength, e);
        let n = super.set(e, t);
        return this.ranges.add(t, n.byteLength), n;
    }
    async ensureChunk(e, t) {
        this.chunked && (this.ranges.available(e, t) || await this.readChunk(e, t));
    }
    available(e, t) {
        return this.ranges.available(e, t);
    }
}
class Oe {
    constructor(){
        c(this, "list", []);
    }
    get length() {
        return this.list.length;
    }
    add(e, t, i = 0) {
        let n = e + t, s = this.list.filter((t)=>xe(e, t.offset, n) || xe(e, t.end, n));
        if (s.length > 0) {
            e = Math.min(e, ...s.map((e)=>e.offset)), n = Math.max(n, ...s.map((e)=>e.end)), t = n - e;
            let i = s.shift();
            i.offset = e, i.length = t, i.end = n, this.list = this.list.filter((e)=>!s.includes(e));
        } else this.list.push({
            offset: e,
            length: t,
            end: n
        });
    }
    available(e, t) {
        let i = e + t;
        return this.list.some((t)=>t.offset <= e && i <= t.end);
    }
}
function xe(e, t, i) {
    return e <= t && t <= i;
}
class ve extends De {
    constructor(e, t){
        super(0), c(this, "chunksRead", 0), this.input = e, this.options = t;
    }
    async readWhole() {
        this.chunked = !1, await this.readChunk(this.nextChunkOffset);
    }
    async readChunked() {
        this.chunked = !0, await this.readChunk(0, this.options.firstChunkSize);
    }
    async readNextChunk(e = this.nextChunkOffset) {
        if (this.fullyRead) return this.chunksRead++, !1;
        let t = this.options.chunkSize, i = await this.readChunk(e, t);
        return !!i && i.byteLength === t;
    }
    async readChunk(e, t) {
        if (this.chunksRead++, 0 !== (t = this.safeWrapAddress(e, t))) return this._readChunk(e, t);
    }
    safeWrapAddress(e, t) {
        return void 0 !== this.size && e + t > this.size ? Math.max(0, this.size - e) : t;
    }
    get nextChunkOffset() {
        if (0 !== this.ranges.list.length) return this.ranges.list[0].length;
    }
    get canReadNextChunk() {
        return this.chunksRead < this.options.chunkLimit;
    }
    get fullyRead() {
        return void 0 !== this.size && this.nextChunkOffset === this.size;
    }
    read() {
        return this.options.chunked ? this.readChunked() : this.readWhole();
    }
    close() {}
}
A.set("blob", class extends ve {
    async readWhole() {
        this.chunked = !1;
        let e = await R(this.input);
        this._swapArrayBuffer(e);
    }
    readChunked() {
        return this.chunked = !0, this.size = this.input.size, super.readChunked();
    }
    async _readChunk(e, t) {
        let i = t ? e + t : void 0, n = this.input.slice(e, i), s = await R(n);
        return this.set(s, e, !0);
    }
});
var Me = Object.freeze({
    __proto__: null,
    default: pe,
    Exifr: te,
    fileParsers: w,
    segmentParsers: T,
    fileReaders: A,
    tagKeys: E,
    tagValues: B,
    tagRevivers: N,
    createDictionary: U,
    extendDictionary: F,
    fetchUrlAsArrayBuffer: M,
    readBlobAsArrayBuffer: R,
    chunkedProps: G,
    otherSegments: V,
    segments: z,
    tiffBlocks: H,
    segmentsAndBlocks: j,
    tiffExtractables: W,
    inheritables: K,
    allFormatters: X,
    Options: q,
    parse: ie,
    gpsOnlyOptions: me,
    gps: Se,
    thumbnailOnlyOptions: Ce,
    thumbnail: ye,
    thumbnailUrl: be,
    orientationOnlyOptions: Ie,
    orientation: Pe,
    rotations: ke,
    get rotateCanvas () {
        return we;
    },
    get rotateCss () {
        return Te;
    },
    rotation: Ae
});
A.set("url", class extends ve {
    async readWhole() {
        this.chunked = !1;
        let e = await M(this.input);
        e instanceof ArrayBuffer ? this._swapArrayBuffer(e) : e instanceof Uint8Array && this._swapBuffer(e);
    }
    async _readChunk(e, t) {
        let i = t ? e + t - 1 : void 0, n = this.options.httpHeaders || {};
        (e || i) && (n.range = `bytes=${[
            e,
            i
        ].join("-")}`);
        let s = await h(this.input, {
            headers: n
        }), r = await s.arrayBuffer(), a = r.byteLength;
        if (416 !== s.status) return a !== t && (this.size = e + a), this.set(r, e, !0);
    }
});
I.prototype.getUint64 = function(e) {
    let t = this.getUint32(e), i = this.getUint32(e + 4);
    return t < 1048575 ? t << 32 | i : void 0 !== typeof r ? (console.warn("Using BigInt because of type 64uint but JS can only handle 53b numbers."), r(t) << r(32) | r(i)) : void g("Trying to read 64b value but JS can only handle 53b numbers.");
};
class Re extends se {
    parseBoxes(e = 0) {
        let t = [];
        for(; e < this.file.byteLength - 4;){
            let i = this.parseBoxHead(e);
            if (t.push(i), 0 === i.length) break;
            e += i.length;
        }
        return t;
    }
    parseSubBoxes(e) {
        e.boxes = this.parseBoxes(e.start);
    }
    findBox(e, t) {
        return void 0 === e.boxes && this.parseSubBoxes(e), e.boxes.find((e)=>e.kind === t);
    }
    parseBoxHead(e) {
        let t = this.file.getUint32(e), i = this.file.getString(e + 4, 4), n = e + 8;
        return 1 === t && (t = this.file.getUint64(e + 8), n += 8), {
            offset: e,
            length: t,
            kind: i,
            start: n
        };
    }
    parseBoxFullHead(e) {
        if (void 0 !== e.version) return;
        let t = this.file.getUint32(e.start);
        e.version = t >> 24, e.start += 4;
    }
}
class Le extends Re {
    static canHandle(e, t) {
        if (0 !== t) return !1;
        let i = e.getUint16(2);
        if (i > 50) return !1;
        let n = 16, s = [];
        for(; n < i;)s.push(e.getString(n, 4)), n += 4;
        return s.includes(this.type);
    }
    async parse() {
        let e = this.file.getUint32(0), t = this.parseBoxHead(e);
        for(; "meta" !== t.kind;)e += t.length, await this.file.ensureChunk(e, 16), t = this.parseBoxHead(e);
        await this.file.ensureChunk(t.offset, t.length), this.parseBoxFullHead(t), this.parseSubBoxes(t), this.options.icc.enabled && await this.findIcc(t), this.options.tiff.enabled && await this.findExif(t);
    }
    async registerSegment(e, t, i) {
        await this.file.ensureChunk(t, i);
        let n = this.file.subarray(t, i);
        this.createParser(e, n);
    }
    async findIcc(e) {
        let t = this.findBox(e, "iprp");
        if (void 0 === t) return;
        let i = this.findBox(t, "ipco");
        if (void 0 === i) return;
        let n = this.findBox(i, "colr");
        void 0 !== n && await this.registerSegment("icc", n.offset + 12, n.length);
    }
    async findExif(e) {
        let t = this.findBox(e, "iinf");
        if (void 0 === t) return;
        let i = this.findBox(e, "iloc");
        if (void 0 === i) return;
        let n = this.findExifLocIdInIinf(t), s = this.findExtentInIloc(i, n);
        if (void 0 === s) return;
        let [r, a] = s;
        await this.file.ensureChunk(r, a);
        let o = 4 + this.file.getUint32(r);
        r += o, a -= o, await this.registerSegment("tiff", r, a);
    }
    findExifLocIdInIinf(e) {
        this.parseBoxFullHead(e);
        let t, i, n, s, r = e.start, a = this.file.getUint16(r);
        for(r += 2; a--;){
            if (t = this.parseBoxHead(r), this.parseBoxFullHead(t), i = t.start, t.version >= 2 && (n = 3 === t.version ? 4 : 2, s = this.file.getString(i + n + 2, 4), "Exif" === s)) return this.file.getUintBytes(i, n);
            r += t.length;
        }
    }
    get8bits(e) {
        let t = this.file.getUint8(e);
        return [
            t >> 4,
            15 & t
        ];
    }
    findExtentInIloc(e, t) {
        this.parseBoxFullHead(e);
        let i = e.start, [n, s] = this.get8bits(i++), [r, a] = this.get8bits(i++), o = 2 === e.version ? 4 : 2, l = 1 === e.version || 2 === e.version ? 2 : 0, h = a + n + s, u = 2 === e.version ? 4 : 2, c = this.file.getUintBytes(i, u);
        for(i += u; c--;){
            let e = this.file.getUintBytes(i, o);
            i += o + l + 2 + r;
            let u = this.file.getUint16(i);
            if (i += 2, e === t) return u > 1 && console.warn("ILOC box has more than one extent but we're only processing one\nPlease create an issue at https://github.com/MikeKovarik/exifr with this file"), [
                this.file.getUintBytes(i + a, n),
                this.file.getUintBytes(i + a + n, s)
            ];
            i += u * h;
        }
    }
}
class Ue extends Le {
}
c(Ue, "type", "heic");
class Fe extends Le {
}
c(Fe, "type", "avif"), w.set("heic", Ue), w.set("avif", Fe), U(E, [
    "ifd0",
    "ifd1"
], [
    [
        256,
        "ImageWidth"
    ],
    [
        257,
        "ImageHeight"
    ],
    [
        258,
        "BitsPerSample"
    ],
    [
        259,
        "Compression"
    ],
    [
        262,
        "PhotometricInterpretation"
    ],
    [
        270,
        "ImageDescription"
    ],
    [
        271,
        "Make"
    ],
    [
        272,
        "Model"
    ],
    [
        273,
        "StripOffsets"
    ],
    [
        274,
        "Orientation"
    ],
    [
        277,
        "SamplesPerPixel"
    ],
    [
        278,
        "RowsPerStrip"
    ],
    [
        279,
        "StripByteCounts"
    ],
    [
        282,
        "XResolution"
    ],
    [
        283,
        "YResolution"
    ],
    [
        284,
        "PlanarConfiguration"
    ],
    [
        296,
        "ResolutionUnit"
    ],
    [
        301,
        "TransferFunction"
    ],
    [
        305,
        "Software"
    ],
    [
        306,
        "ModifyDate"
    ],
    [
        315,
        "Artist"
    ],
    [
        316,
        "HostComputer"
    ],
    [
        317,
        "Predictor"
    ],
    [
        318,
        "WhitePoint"
    ],
    [
        319,
        "PrimaryChromaticities"
    ],
    [
        513,
        "ThumbnailOffset"
    ],
    [
        514,
        "ThumbnailLength"
    ],
    [
        529,
        "YCbCrCoefficients"
    ],
    [
        530,
        "YCbCrSubSampling"
    ],
    [
        531,
        "YCbCrPositioning"
    ],
    [
        532,
        "ReferenceBlackWhite"
    ],
    [
        700,
        "ApplicationNotes"
    ],
    [
        33432,
        "Copyright"
    ],
    [
        33723,
        "IPTC"
    ],
    [
        34665,
        "ExifIFD"
    ],
    [
        34675,
        "ICC"
    ],
    [
        34853,
        "GpsIFD"
    ],
    [
        330,
        "SubIFD"
    ],
    [
        40965,
        "InteropIFD"
    ],
    [
        40091,
        "XPTitle"
    ],
    [
        40092,
        "XPComment"
    ],
    [
        40093,
        "XPAuthor"
    ],
    [
        40094,
        "XPKeywords"
    ],
    [
        40095,
        "XPSubject"
    ]
]), U(E, "exif", [
    [
        33434,
        "ExposureTime"
    ],
    [
        33437,
        "FNumber"
    ],
    [
        34850,
        "ExposureProgram"
    ],
    [
        34852,
        "SpectralSensitivity"
    ],
    [
        34855,
        "ISO"
    ],
    [
        34858,
        "TimeZoneOffset"
    ],
    [
        34859,
        "SelfTimerMode"
    ],
    [
        34864,
        "SensitivityType"
    ],
    [
        34865,
        "StandardOutputSensitivity"
    ],
    [
        34866,
        "RecommendedExposureIndex"
    ],
    [
        34867,
        "ISOSpeed"
    ],
    [
        34868,
        "ISOSpeedLatitudeyyy"
    ],
    [
        34869,
        "ISOSpeedLatitudezzz"
    ],
    [
        36864,
        "ExifVersion"
    ],
    [
        36867,
        "DateTimeOriginal"
    ],
    [
        36868,
        "CreateDate"
    ],
    [
        36873,
        "GooglePlusUploadCode"
    ],
    [
        36880,
        "OffsetTime"
    ],
    [
        36881,
        "OffsetTimeOriginal"
    ],
    [
        36882,
        "OffsetTimeDigitized"
    ],
    [
        37121,
        "ComponentsConfiguration"
    ],
    [
        37122,
        "CompressedBitsPerPixel"
    ],
    [
        37377,
        "ShutterSpeedValue"
    ],
    [
        37378,
        "ApertureValue"
    ],
    [
        37379,
        "BrightnessValue"
    ],
    [
        37380,
        "ExposureCompensation"
    ],
    [
        37381,
        "MaxApertureValue"
    ],
    [
        37382,
        "SubjectDistance"
    ],
    [
        37383,
        "MeteringMode"
    ],
    [
        37384,
        "LightSource"
    ],
    [
        37385,
        "Flash"
    ],
    [
        37386,
        "FocalLength"
    ],
    [
        37393,
        "ImageNumber"
    ],
    [
        37394,
        "SecurityClassification"
    ],
    [
        37395,
        "ImageHistory"
    ],
    [
        37396,
        "SubjectArea"
    ],
    [
        37500,
        "MakerNote"
    ],
    [
        37510,
        "UserComment"
    ],
    [
        37520,
        "SubSecTime"
    ],
    [
        37521,
        "SubSecTimeOriginal"
    ],
    [
        37522,
        "SubSecTimeDigitized"
    ],
    [
        37888,
        "AmbientTemperature"
    ],
    [
        37889,
        "Humidity"
    ],
    [
        37890,
        "Pressure"
    ],
    [
        37891,
        "WaterDepth"
    ],
    [
        37892,
        "Acceleration"
    ],
    [
        37893,
        "CameraElevationAngle"
    ],
    [
        40960,
        "FlashpixVersion"
    ],
    [
        40961,
        "ColorSpace"
    ],
    [
        40962,
        "ExifImageWidth"
    ],
    [
        40963,
        "ExifImageHeight"
    ],
    [
        40964,
        "RelatedSoundFile"
    ],
    [
        41483,
        "FlashEnergy"
    ],
    [
        41486,
        "FocalPlaneXResolution"
    ],
    [
        41487,
        "FocalPlaneYResolution"
    ],
    [
        41488,
        "FocalPlaneResolutionUnit"
    ],
    [
        41492,
        "SubjectLocation"
    ],
    [
        41493,
        "ExposureIndex"
    ],
    [
        41495,
        "SensingMethod"
    ],
    [
        41728,
        "FileSource"
    ],
    [
        41729,
        "SceneType"
    ],
    [
        41730,
        "CFAPattern"
    ],
    [
        41985,
        "CustomRendered"
    ],
    [
        41986,
        "ExposureMode"
    ],
    [
        41987,
        "WhiteBalance"
    ],
    [
        41988,
        "DigitalZoomRatio"
    ],
    [
        41989,
        "FocalLengthIn35mmFormat"
    ],
    [
        41990,
        "SceneCaptureType"
    ],
    [
        41991,
        "GainControl"
    ],
    [
        41992,
        "Contrast"
    ],
    [
        41993,
        "Saturation"
    ],
    [
        41994,
        "Sharpness"
    ],
    [
        41996,
        "SubjectDistanceRange"
    ],
    [
        42016,
        "ImageUniqueID"
    ],
    [
        42032,
        "OwnerName"
    ],
    [
        42033,
        "SerialNumber"
    ],
    [
        42034,
        "LensInfo"
    ],
    [
        42035,
        "LensMake"
    ],
    [
        42036,
        "LensModel"
    ],
    [
        42037,
        "LensSerialNumber"
    ],
    [
        42080,
        "CompositeImage"
    ],
    [
        42081,
        "CompositeImageCount"
    ],
    [
        42082,
        "CompositeImageExposureTimes"
    ],
    [
        42240,
        "Gamma"
    ],
    [
        59932,
        "Padding"
    ],
    [
        59933,
        "OffsetSchema"
    ],
    [
        65e3,
        "OwnerName"
    ],
    [
        65001,
        "SerialNumber"
    ],
    [
        65002,
        "Lens"
    ],
    [
        65100,
        "RawFile"
    ],
    [
        65101,
        "Converter"
    ],
    [
        65102,
        "WhiteBalance"
    ],
    [
        65105,
        "Exposure"
    ],
    [
        65106,
        "Shadows"
    ],
    [
        65107,
        "Brightness"
    ],
    [
        65108,
        "Contrast"
    ],
    [
        65109,
        "Saturation"
    ],
    [
        65110,
        "Sharpness"
    ],
    [
        65111,
        "Smoothness"
    ],
    [
        65112,
        "MoireFilter"
    ],
    [
        40965,
        "InteropIFD"
    ]
]), U(E, "gps", [
    [
        0,
        "GPSVersionID"
    ],
    [
        1,
        "GPSLatitudeRef"
    ],
    [
        2,
        "GPSLatitude"
    ],
    [
        3,
        "GPSLongitudeRef"
    ],
    [
        4,
        "GPSLongitude"
    ],
    [
        5,
        "GPSAltitudeRef"
    ],
    [
        6,
        "GPSAltitude"
    ],
    [
        7,
        "GPSTimeStamp"
    ],
    [
        8,
        "GPSSatellites"
    ],
    [
        9,
        "GPSStatus"
    ],
    [
        10,
        "GPSMeasureMode"
    ],
    [
        11,
        "GPSDOP"
    ],
    [
        12,
        "GPSSpeedRef"
    ],
    [
        13,
        "GPSSpeed"
    ],
    [
        14,
        "GPSTrackRef"
    ],
    [
        15,
        "GPSTrack"
    ],
    [
        16,
        "GPSImgDirectionRef"
    ],
    [
        17,
        "GPSImgDirection"
    ],
    [
        18,
        "GPSMapDatum"
    ],
    [
        19,
        "GPSDestLatitudeRef"
    ],
    [
        20,
        "GPSDestLatitude"
    ],
    [
        21,
        "GPSDestLongitudeRef"
    ],
    [
        22,
        "GPSDestLongitude"
    ],
    [
        23,
        "GPSDestBearingRef"
    ],
    [
        24,
        "GPSDestBearing"
    ],
    [
        25,
        "GPSDestDistanceRef"
    ],
    [
        26,
        "GPSDestDistance"
    ],
    [
        27,
        "GPSProcessingMethod"
    ],
    [
        28,
        "GPSAreaInformation"
    ],
    [
        29,
        "GPSDateStamp"
    ],
    [
        30,
        "GPSDifferential"
    ],
    [
        31,
        "GPSHPositioningError"
    ]
]), U(B, [
    "ifd0",
    "ifd1"
], [
    [
        274,
        {
            1: "Horizontal (normal)",
            2: "Mirror horizontal",
            3: "Rotate 180",
            4: "Mirror vertical",
            5: "Mirror horizontal and rotate 270 CW",
            6: "Rotate 90 CW",
            7: "Mirror horizontal and rotate 90 CW",
            8: "Rotate 270 CW"
        }
    ],
    [
        296,
        {
            1: "None",
            2: "inches",
            3: "cm"
        }
    ]
]);
let Ee = U(B, "exif", [
    [
        34850,
        {
            0: "Not defined",
            1: "Manual",
            2: "Normal program",
            3: "Aperture priority",
            4: "Shutter priority",
            5: "Creative program",
            6: "Action program",
            7: "Portrait mode",
            8: "Landscape mode"
        }
    ],
    [
        37121,
        {
            0: "-",
            1: "Y",
            2: "Cb",
            3: "Cr",
            4: "R",
            5: "G",
            6: "B"
        }
    ],
    [
        37383,
        {
            0: "Unknown",
            1: "Average",
            2: "CenterWeightedAverage",
            3: "Spot",
            4: "MultiSpot",
            5: "Pattern",
            6: "Partial",
            255: "Other"
        }
    ],
    [
        37384,
        {
            0: "Unknown",
            1: "Daylight",
            2: "Fluorescent",
            3: "Tungsten (incandescent light)",
            4: "Flash",
            9: "Fine weather",
            10: "Cloudy weather",
            11: "Shade",
            12: "Daylight fluorescent (D 5700 - 7100K)",
            13: "Day white fluorescent (N 4600 - 5400K)",
            14: "Cool white fluorescent (W 3900 - 4500K)",
            15: "White fluorescent (WW 3200 - 3700K)",
            17: "Standard light A",
            18: "Standard light B",
            19: "Standard light C",
            20: "D55",
            21: "D65",
            22: "D75",
            23: "D50",
            24: "ISO studio tungsten",
            255: "Other"
        }
    ],
    [
        37385,
        {
            0: "Flash did not fire",
            1: "Flash fired",
            5: "Strobe return light not detected",
            7: "Strobe return light detected",
            9: "Flash fired, compulsory flash mode",
            13: "Flash fired, compulsory flash mode, return light not detected",
            15: "Flash fired, compulsory flash mode, return light detected",
            16: "Flash did not fire, compulsory flash mode",
            24: "Flash did not fire, auto mode",
            25: "Flash fired, auto mode",
            29: "Flash fired, auto mode, return light not detected",
            31: "Flash fired, auto mode, return light detected",
            32: "No flash function",
            65: "Flash fired, red-eye reduction mode",
            69: "Flash fired, red-eye reduction mode, return light not detected",
            71: "Flash fired, red-eye reduction mode, return light detected",
            73: "Flash fired, compulsory flash mode, red-eye reduction mode",
            77: "Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected",
            79: "Flash fired, compulsory flash mode, red-eye reduction mode, return light detected",
            89: "Flash fired, auto mode, red-eye reduction mode",
            93: "Flash fired, auto mode, return light not detected, red-eye reduction mode",
            95: "Flash fired, auto mode, return light detected, red-eye reduction mode"
        }
    ],
    [
        41495,
        {
            1: "Not defined",
            2: "One-chip color area sensor",
            3: "Two-chip color area sensor",
            4: "Three-chip color area sensor",
            5: "Color sequential area sensor",
            7: "Trilinear sensor",
            8: "Color sequential linear sensor"
        }
    ],
    [
        41728,
        {
            1: "Film Scanner",
            2: "Reflection Print Scanner",
            3: "Digital Camera"
        }
    ],
    [
        41729,
        {
            1: "Directly photographed"
        }
    ],
    [
        41985,
        {
            0: "Normal",
            1: "Custom",
            2: "HDR (no original saved)",
            3: "HDR (original saved)",
            4: "Original (for HDR)",
            6: "Panorama",
            7: "Portrait HDR",
            8: "Portrait"
        }
    ],
    [
        41986,
        {
            0: "Auto",
            1: "Manual",
            2: "Auto bracket"
        }
    ],
    [
        41987,
        {
            0: "Auto",
            1: "Manual"
        }
    ],
    [
        41990,
        {
            0: "Standard",
            1: "Landscape",
            2: "Portrait",
            3: "Night",
            4: "Other"
        }
    ],
    [
        41991,
        {
            0: "None",
            1: "Low gain up",
            2: "High gain up",
            3: "Low gain down",
            4: "High gain down"
        }
    ],
    [
        41996,
        {
            0: "Unknown",
            1: "Macro",
            2: "Close",
            3: "Distant"
        }
    ],
    [
        42080,
        {
            0: "Unknown",
            1: "Not a Composite Image",
            2: "General Composite Image",
            3: "Composite Image Captured While Shooting"
        }
    ]
]);
const Be = {
    1: "No absolute unit of measurement",
    2: "Inch",
    3: "Centimeter"
};
Ee.set(37392, Be), Ee.set(41488, Be);
const Ne = {
    0: "Normal",
    1: "Low",
    2: "High"
};
function Ge(e) {
    return "object" == typeof e && void 0 !== e.length ? e[0] : e;
}
function Ve(e) {
    let t = Array.from(e).slice(1);
    return t[1] > 15 && (t = t.map((e)=>String.fromCharCode(e))), "0" !== t[2] && 0 !== t[2] || t.pop(), t.join(".");
}
function ze(e) {
    if ("string" == typeof e) {
        var [t, i, n, s, r, a] = e.trim().split(/[-: ]/g).map(Number), o = new Date(t, i - 1, n);
        return Number.isNaN(s) || Number.isNaN(r) || Number.isNaN(a) || (o.setHours(s), o.setMinutes(r), o.setSeconds(a)), Number.isNaN(+o) ? e : o;
    }
}
function He(e) {
    if ("string" == typeof e) return e;
    let t = [];
    if (0 === e[1] && 0 === e[e.length - 1]) for(let i = 0; i < e.length; i += 2)t.push(je(e[i + 1], e[i]));
    else for(let i = 0; i < e.length; i += 2)t.push(je(e[i], e[i + 1]));
    return m(String.fromCodePoint(...t));
}
function je(e, t) {
    return e << 8 | t;
}
Ee.set(41992, Ne), Ee.set(41993, Ne), Ee.set(41994, Ne), U(N, [
    "ifd0",
    "ifd1"
], [
    [
        50827,
        function(e) {
            return "string" != typeof e ? b(e) : e;
        }
    ],
    [
        306,
        ze
    ],
    [
        40091,
        He
    ],
    [
        40092,
        He
    ],
    [
        40093,
        He
    ],
    [
        40094,
        He
    ],
    [
        40095,
        He
    ]
]), U(N, "exif", [
    [
        40960,
        Ve
    ],
    [
        36864,
        Ve
    ],
    [
        36867,
        ze
    ],
    [
        36868,
        ze
    ],
    [
        40962,
        Ge
    ],
    [
        40963,
        Ge
    ]
]), U(N, "gps", [
    [
        0,
        (e)=>Array.from(e).join(".")
    ],
    [
        7,
        (e)=>Array.from(e).join(":")
    ]
]);
class We extends re {
    static canHandle(e, t) {
        return 225 === e.getUint8(t + 1) && 1752462448 === e.getUint32(t + 4) && "http://ns.adobe.com/" === e.getString(t + 4, "http://ns.adobe.com/".length);
    }
    static headerLength(e, t) {
        return "http://ns.adobe.com/xmp/extension/" === e.getString(t + 4, "http://ns.adobe.com/xmp/extension/".length) ? 79 : 4 + "http://ns.adobe.com/xap/1.0/".length + 1;
    }
    static findPosition(e, t) {
        let i = super.findPosition(e, t);
        return i.multiSegment = i.extended = 79 === i.headerLength, i.multiSegment ? (i.chunkCount = e.getUint8(t + 72), i.chunkNumber = e.getUint8(t + 76), 0 !== e.getUint8(t + 77) && i.chunkNumber++) : (i.chunkCount = 1 / 0, i.chunkNumber = -1), i;
    }
    static handleMultiSegments(e) {
        return e.map((e)=>e.chunk.getString()).join("");
    }
    normalizeInput(e) {
        return "string" == typeof e ? e : I.from(e).getString();
    }
    parse(e = this.chunk) {
        if (!this.localOptions.parse) return e;
        e = function(e) {
            let t = {}, i = {};
            for (let e of Ze)t[e] = [], i[e] = 0;
            return e.replace(et, (e, n, s)=>{
                if ("<" === n) {
                    let n = ++i[s];
                    return t[s].push(n), `${e}#${n}`;
                }
                return `${e}#${t[s].pop()}`;
            });
        }(e);
        let t = Xe.findAll(e, "rdf", "Description");
        0 === t.length && t.push(new Xe("rdf", "Description", void 0, e));
        let i, n = {};
        for (let e of t)for (let t of e.properties)i = Je(t.ns, n), _e(t, i);
        return function(e) {
            let t;
            for(let i in e)t = e[i] = f(e[i]), void 0 === t && delete e[i];
            return f(e);
        }(n);
    }
    assignToOutput(e, t) {
        if (this.localOptions.parse) for (let [i, n] of Object.entries(t))switch(i){
            case "tiff":
                this.assignObjectToOutput(e, "ifd0", n);
                break;
            case "exif":
                this.assignObjectToOutput(e, "exif", n);
                break;
            case "xmlns":
                break;
            default:
                this.assignObjectToOutput(e, i, n);
        }
        else e.xmp = t;
    }
}
c(We, "type", "xmp"), c(We, "multiSegment", !0), T.set("xmp", We);
class Ke {
    static findAll(e) {
        return qe(e, /([a-zA-Z0-9-]+):([a-zA-Z0-9-]+)=("[^"]*"|'[^']*')/gm).map(Ke.unpackMatch);
    }
    static unpackMatch(e) {
        let t = e[1], i = e[2], n = e[3].slice(1, -1);
        return n = Qe(n), new Ke(t, i, n);
    }
    constructor(e, t, i){
        this.ns = e, this.name = t, this.value = i;
    }
    serialize() {
        return this.value;
    }
}
class Xe {
    static findAll(e, t, i) {
        if (void 0 !== t || void 0 !== i) {
            t = t || "[\\w\\d-]+", i = i || "[\\w\\d-]+";
            var n = new RegExp(`<(${t}):(${i})(#\\d+)?((\\s+?[\\w\\d-:]+=("[^"]*"|'[^']*'))*\\s*)(\\/>|>([\\s\\S]*?)<\\/\\1:\\2\\3>)`, "gm");
        } else n = /<([\w\d-]+):([\w\d-]+)(#\d+)?((\s+?[\w\d-:]+=("[^"]*"|'[^']*'))*\s*)(\/>|>([\s\S]*?)<\/\1:\2\3>)/gm;
        return qe(e, n).map(Xe.unpackMatch);
    }
    static unpackMatch(e) {
        let t = e[1], i = e[2], n = e[4], s = e[8];
        return new Xe(t, i, n, s);
    }
    constructor(e, t, i, n){
        this.ns = e, this.name = t, this.attrString = i, this.innerXml = n, this.attrs = Ke.findAll(i), this.children = Xe.findAll(n), this.value = 0 === this.children.length ? Qe(n) : void 0, this.properties = [
            ...this.attrs,
            ...this.children
        ];
    }
    get isPrimitive() {
        return void 0 !== this.value && 0 === this.attrs.length && 0 === this.children.length;
    }
    get isListContainer() {
        return 1 === this.children.length && this.children[0].isList;
    }
    get isList() {
        let { ns: e, name: t } = this;
        return "rdf" === e && ("Seq" === t || "Bag" === t || "Alt" === t);
    }
    get isListItem() {
        return "rdf" === this.ns && "li" === this.name;
    }
    serialize() {
        if (0 === this.properties.length && void 0 === this.value) return;
        if (this.isPrimitive) return this.value;
        if (this.isListContainer) return this.children[0].serialize();
        if (this.isList) return $e(this.children.map(Ye));
        if (this.isListItem && 1 === this.children.length && 0 === this.attrs.length) return this.children[0].serialize();
        let e = {};
        for (let t of this.properties)_e(t, e);
        return void 0 !== this.value && (e.value = this.value), f(e);
    }
}
function _e(e, t) {
    let i = e.serialize();
    void 0 !== i && (t[e.name] = i);
}
var Ye = (e)=>e.serialize(), $e = (e)=>1 === e.length ? e[0] : e, Je = (e, t)=>t[e] ? t[e] : t[e] = {};
function qe(e, t) {
    let i, n = [];
    if (!e) return n;
    for(; null !== (i = t.exec(e));)n.push(i);
    return n;
}
function Qe(e) {
    if (function(e) {
        return null == e || "null" === e || "undefined" === e || "" === e || "" === e.trim();
    }(e)) return;
    let t = Number(e);
    if (!Number.isNaN(t)) return t;
    let i = e.toLowerCase();
    return "true" === i || "false" !== i && e.trim();
}
const Ze = [
    "rdf:li",
    "rdf:Seq",
    "rdf:Bag",
    "rdf:Alt",
    "rdf:Description"
], et = new RegExp(`(<|\\/)(${Ze.join("|")})`, "g");
var tt = Object.freeze({
    __proto__: null,
    default: Me,
    Exifr: te,
    fileParsers: w,
    segmentParsers: T,
    fileReaders: A,
    tagKeys: E,
    tagValues: B,
    tagRevivers: N,
    createDictionary: U,
    extendDictionary: F,
    fetchUrlAsArrayBuffer: M,
    readBlobAsArrayBuffer: R,
    chunkedProps: G,
    otherSegments: V,
    segments: z,
    tiffBlocks: H,
    segmentsAndBlocks: j,
    tiffExtractables: W,
    inheritables: K,
    allFormatters: X,
    Options: q,
    parse: ie,
    gpsOnlyOptions: me,
    gps: Se,
    thumbnailOnlyOptions: Ce,
    thumbnail: ye,
    thumbnailUrl: be,
    orientationOnlyOptions: Ie,
    orientation: Pe,
    rotations: ke,
    get rotateCanvas () {
        return we;
    },
    get rotateCss () {
        return Te;
    },
    rotation: Ae
});
const it = [
    "xmp",
    "icc",
    "iptc",
    "tiff"
], nt = ()=>{};
async function st(e, t, i) {
    let n = new q(t);
    n.chunked = !1, void 0 === i && "string" == typeof e && (i = function(e) {
        let t = e.toLowerCase().split(".").pop();
        if (function(e) {
            return "exif" === e || "tiff" === e || "tif" === e;
        }(t)) return "tiff";
        if (it.includes(t)) return t;
    }(e));
    let s = await D(e, n);
    if (i) {
        if (it.includes(i)) return rt(i, s, n);
        g("Invalid segment type");
    } else {
        if (function(e) {
            let t = e.getString(0, 50).trim();
            return t.includes("<?xpacket") || t.includes("<x:");
        }(s)) return rt("xmp", s, n);
        for (let [e] of T){
            if (!it.includes(e)) continue;
            let t = await rt(e, s, n).catch(nt);
            if (t) return t;
        }
        g("Unknown file format");
    }
}
async function rt(e, t, i) {
    let n = i[e];
    return n.enabled = !0, n.parse = !0, T.get(e).parse(t, n);
}
let at = l("fs", (e)=>e.promises);
A.set("fs", class extends ve {
    async readWhole() {
        this.chunked = !1, this.fs = await at;
        let e = await this.fs.readFile(this.input);
        this._swapBuffer(e);
    }
    async readChunked() {
        this.chunked = !0, this.fs = await at, await this.open(), await this.readChunk(0, this.options.firstChunkSize);
    }
    async open() {
        void 0 === this.fh && (this.fh = await this.fs.open(this.input, "r"), this.size = (await this.fh.stat(this.input)).size);
    }
    async _readChunk(e, t) {
        void 0 === this.fh && await this.open(), e + t > this.size && (t = this.size - e);
        var i = this.subarray(e, t, !0);
        return await this.fh.read(i.dataView, 0, t, e), i;
    }
    async close() {
        if (this.fh) {
            let e = this.fh;
            this.fh = void 0, await e.close();
        }
    }
});
A.set("base64", class extends ve {
    constructor(...e){
        super(...e), this.input = this.input.replace(/^data:([^;]+);base64,/gim, ""), this.size = this.input.length / 4 * 3, this.input.endsWith("==") ? this.size -= 2 : this.input.endsWith("=") && (this.size -= 1);
    }
    async _readChunk(e, t) {
        let i, n, r = this.input;
        void 0 === e ? (e = 0, i = 0, n = 0) : (i = 4 * Math.floor(e / 3), n = e - i / 4 * 3), void 0 === t && (t = this.size);
        let o = e + t, l = i + 4 * Math.ceil(o / 3);
        r = r.slice(i, l);
        let h = Math.min(t, this.size - e);
        if (a) {
            let t = s.from(r, "base64").slice(n, n + h);
            return this.set(t, e, !0);
        }
        {
            let t = this.subarray(e, h, !0), i = atob(r), s = t.toUint8();
            for(let e = 0; e < h; e++)s[e] = i.charCodeAt(n + e);
            return t;
        }
    }
});
class ot extends se {
    static canHandle(e, t) {
        return 18761 === t || 19789 === t;
    }
    extendOptions(e) {
        let { ifd0: t, xmp: i, iptc: n, icc: s } = e;
        i.enabled && t.deps.add(700), n.enabled && t.deps.add(33723), s.enabled && t.deps.add(34675), t.finalizeFilters();
    }
    async parse() {
        let { tiff: e, xmp: t, iptc: i, icc: n } = this.options;
        if (e.enabled || t.enabled || i.enabled || n.enabled) {
            let e = Math.max(S(this.options), this.options.chunkSize);
            await this.file.ensureChunk(0, e), this.createParser("tiff", this.file), this.parsers.tiff.parseHeader(), await this.parsers.tiff.parseIfd0Block(), this.adaptTiffPropAsSegment("xmp"), this.adaptTiffPropAsSegment("iptc"), this.adaptTiffPropAsSegment("icc");
        }
    }
    adaptTiffPropAsSegment(e) {
        if (this.parsers.tiff[e]) {
            let t = this.parsers.tiff[e];
            this.injectSegment(e, t);
        }
    }
}
c(ot, "type", "tiff"), w.set("tiff", ot);
let lt = l("zlib");
const ht = [
    "ihdr",
    "iccp",
    "text",
    "itxt",
    "exif"
];
class ut extends se {
    constructor(...e){
        super(...e), c(this, "catchError", (e)=>this.errors.push(e)), c(this, "metaChunks", []), c(this, "unknownChunks", []);
    }
    static canHandle(e, t) {
        return 35152 === t && 2303741511 === e.getUint32(0) && 218765834 === e.getUint32(4);
    }
    async parse() {
        let { file: e } = this;
        await this.findPngChunksInRange("PNG\r\n\n".length, e.byteLength), await this.readSegments(this.metaChunks), this.findIhdr(), this.parseTextChunks(), await this.findExif().catch(this.catchError), await this.findXmp().catch(this.catchError), await this.findIcc().catch(this.catchError);
    }
    async findPngChunksInRange(e, t) {
        let { file: i } = this;
        for(; e < t;){
            let t = i.getUint32(e), n = i.getUint32(e + 4), s = i.getString(e + 4, 4).toLowerCase(), r = t + 4 + 4 + 4, a = {
                type: s,
                offset: e,
                length: r,
                start: e + 4 + 4,
                size: t,
                marker: n
            };
            ht.includes(s) ? this.metaChunks.push(a) : this.unknownChunks.push(a), e += r;
        }
    }
    parseTextChunks() {
        let e = this.metaChunks.filter((e)=>"text" === e.type);
        for (let t of e){
            let [e, i] = this.file.getString(t.start, t.size).split("\0");
            this.injectKeyValToIhdr(e, i);
        }
    }
    injectKeyValToIhdr(e, t) {
        let i = this.parsers.ihdr;
        i && i.raw.set(e, t);
    }
    findIhdr() {
        let e = this.metaChunks.find((e)=>"ihdr" === e.type);
        e && !1 !== this.options.ihdr.enabled && this.createParser("ihdr", e.chunk);
    }
    async findExif() {
        let e = this.metaChunks.find((e)=>"exif" === e.type);
        e && this.injectSegment("tiff", e.chunk);
    }
    async findXmp() {
        let e = this.metaChunks.filter((e)=>"itxt" === e.type);
        for (let t of e){
            "XML:com.adobe.xmp" === t.chunk.getString(0, "XML:com.adobe.xmp".length) && this.injectSegment("xmp", t.chunk);
        }
    }
    async findIcc() {
        let e = this.metaChunks.find((e)=>"iccp" === e.type);
        if (!e) return;
        let { chunk: t } = e, i = t.getUint8Array(0, 81), s = 0;
        for(; s < 80 && 0 !== i[s];)s++;
        let r = s + 2, a = t.getString(0, s);
        if (this.injectKeyValToIhdr("ProfileName", a), n) {
            let e = await lt, i = t.getUint8Array(r);
            i = e.inflateSync(i), this.injectSegment("icc", i);
        }
    }
}
c(ut, "type", "png"), w.set("png", ut), U(E, "interop", [
    [
        1,
        "InteropIndex"
    ],
    [
        2,
        "InteropVersion"
    ],
    [
        4096,
        "RelatedImageFileFormat"
    ],
    [
        4097,
        "RelatedImageWidth"
    ],
    [
        4098,
        "RelatedImageHeight"
    ]
]), F(E, "ifd0", [
    [
        11,
        "ProcessingSoftware"
    ],
    [
        254,
        "SubfileType"
    ],
    [
        255,
        "OldSubfileType"
    ],
    [
        263,
        "Thresholding"
    ],
    [
        264,
        "CellWidth"
    ],
    [
        265,
        "CellLength"
    ],
    [
        266,
        "FillOrder"
    ],
    [
        269,
        "DocumentName"
    ],
    [
        280,
        "MinSampleValue"
    ],
    [
        281,
        "MaxSampleValue"
    ],
    [
        285,
        "PageName"
    ],
    [
        286,
        "XPosition"
    ],
    [
        287,
        "YPosition"
    ],
    [
        290,
        "GrayResponseUnit"
    ],
    [
        297,
        "PageNumber"
    ],
    [
        321,
        "HalftoneHints"
    ],
    [
        322,
        "TileWidth"
    ],
    [
        323,
        "TileLength"
    ],
    [
        332,
        "InkSet"
    ],
    [
        337,
        "TargetPrinter"
    ],
    [
        18246,
        "Rating"
    ],
    [
        18249,
        "RatingPercent"
    ],
    [
        33550,
        "PixelScale"
    ],
    [
        34264,
        "ModelTransform"
    ],
    [
        34377,
        "PhotoshopSettings"
    ],
    [
        50706,
        "DNGVersion"
    ],
    [
        50707,
        "DNGBackwardVersion"
    ],
    [
        50708,
        "UniqueCameraModel"
    ],
    [
        50709,
        "LocalizedCameraModel"
    ],
    [
        50736,
        "DNGLensInfo"
    ],
    [
        50739,
        "ShadowScale"
    ],
    [
        50740,
        "DNGPrivateData"
    ],
    [
        33920,
        "IntergraphMatrix"
    ],
    [
        33922,
        "ModelTiePoint"
    ],
    [
        34118,
        "SEMInfo"
    ],
    [
        34735,
        "GeoTiffDirectory"
    ],
    [
        34736,
        "GeoTiffDoubleParams"
    ],
    [
        34737,
        "GeoTiffAsciiParams"
    ],
    [
        50341,
        "PrintIM"
    ],
    [
        50721,
        "ColorMatrix1"
    ],
    [
        50722,
        "ColorMatrix2"
    ],
    [
        50723,
        "CameraCalibration1"
    ],
    [
        50724,
        "CameraCalibration2"
    ],
    [
        50725,
        "ReductionMatrix1"
    ],
    [
        50726,
        "ReductionMatrix2"
    ],
    [
        50727,
        "AnalogBalance"
    ],
    [
        50728,
        "AsShotNeutral"
    ],
    [
        50729,
        "AsShotWhiteXY"
    ],
    [
        50730,
        "BaselineExposure"
    ],
    [
        50731,
        "BaselineNoise"
    ],
    [
        50732,
        "BaselineSharpness"
    ],
    [
        50734,
        "LinearResponseLimit"
    ],
    [
        50735,
        "CameraSerialNumber"
    ],
    [
        50741,
        "MakerNoteSafety"
    ],
    [
        50778,
        "CalibrationIlluminant1"
    ],
    [
        50779,
        "CalibrationIlluminant2"
    ],
    [
        50781,
        "RawDataUniqueID"
    ],
    [
        50827,
        "OriginalRawFileName"
    ],
    [
        50828,
        "OriginalRawFileData"
    ],
    [
        50831,
        "AsShotICCProfile"
    ],
    [
        50832,
        "AsShotPreProfileMatrix"
    ],
    [
        50833,
        "CurrentICCProfile"
    ],
    [
        50834,
        "CurrentPreProfileMatrix"
    ],
    [
        50879,
        "ColorimetricReference"
    ],
    [
        50885,
        "SRawType"
    ],
    [
        50898,
        "PanasonicTitle"
    ],
    [
        50899,
        "PanasonicTitle2"
    ],
    [
        50931,
        "CameraCalibrationSig"
    ],
    [
        50932,
        "ProfileCalibrationSig"
    ],
    [
        50933,
        "ProfileIFD"
    ],
    [
        50934,
        "AsShotProfileName"
    ],
    [
        50936,
        "ProfileName"
    ],
    [
        50937,
        "ProfileHueSatMapDims"
    ],
    [
        50938,
        "ProfileHueSatMapData1"
    ],
    [
        50939,
        "ProfileHueSatMapData2"
    ],
    [
        50940,
        "ProfileToneCurve"
    ],
    [
        50941,
        "ProfileEmbedPolicy"
    ],
    [
        50942,
        "ProfileCopyright"
    ],
    [
        50964,
        "ForwardMatrix1"
    ],
    [
        50965,
        "ForwardMatrix2"
    ],
    [
        50966,
        "PreviewApplicationName"
    ],
    [
        50967,
        "PreviewApplicationVersion"
    ],
    [
        50968,
        "PreviewSettingsName"
    ],
    [
        50969,
        "PreviewSettingsDigest"
    ],
    [
        50970,
        "PreviewColorSpace"
    ],
    [
        50971,
        "PreviewDateTime"
    ],
    [
        50972,
        "RawImageDigest"
    ],
    [
        50973,
        "OriginalRawFileDigest"
    ],
    [
        50981,
        "ProfileLookTableDims"
    ],
    [
        50982,
        "ProfileLookTableData"
    ],
    [
        51043,
        "TimeCodes"
    ],
    [
        51044,
        "FrameRate"
    ],
    [
        51058,
        "TStop"
    ],
    [
        51081,
        "ReelName"
    ],
    [
        51089,
        "OriginalDefaultFinalSize"
    ],
    [
        51090,
        "OriginalBestQualitySize"
    ],
    [
        51091,
        "OriginalDefaultCropSize"
    ],
    [
        51105,
        "CameraLabel"
    ],
    [
        51107,
        "ProfileHueSatMapEncoding"
    ],
    [
        51108,
        "ProfileLookTableEncoding"
    ],
    [
        51109,
        "BaselineExposureOffset"
    ],
    [
        51110,
        "DefaultBlackRender"
    ],
    [
        51111,
        "NewRawImageDigest"
    ],
    [
        51112,
        "RawToPreviewGain"
    ]
]);
let ct = [
    [
        273,
        "StripOffsets"
    ],
    [
        279,
        "StripByteCounts"
    ],
    [
        288,
        "FreeOffsets"
    ],
    [
        289,
        "FreeByteCounts"
    ],
    [
        291,
        "GrayResponseCurve"
    ],
    [
        292,
        "T4Options"
    ],
    [
        293,
        "T6Options"
    ],
    [
        300,
        "ColorResponseUnit"
    ],
    [
        320,
        "ColorMap"
    ],
    [
        324,
        "TileOffsets"
    ],
    [
        325,
        "TileByteCounts"
    ],
    [
        326,
        "BadFaxLines"
    ],
    [
        327,
        "CleanFaxData"
    ],
    [
        328,
        "ConsecutiveBadFaxLines"
    ],
    [
        330,
        "SubIFD"
    ],
    [
        333,
        "InkNames"
    ],
    [
        334,
        "NumberofInks"
    ],
    [
        336,
        "DotRange"
    ],
    [
        338,
        "ExtraSamples"
    ],
    [
        339,
        "SampleFormat"
    ],
    [
        340,
        "SMinSampleValue"
    ],
    [
        341,
        "SMaxSampleValue"
    ],
    [
        342,
        "TransferRange"
    ],
    [
        343,
        "ClipPath"
    ],
    [
        344,
        "XClipPathUnits"
    ],
    [
        345,
        "YClipPathUnits"
    ],
    [
        346,
        "Indexed"
    ],
    [
        347,
        "JPEGTables"
    ],
    [
        351,
        "OPIProxy"
    ],
    [
        400,
        "GlobalParametersIFD"
    ],
    [
        401,
        "ProfileType"
    ],
    [
        402,
        "FaxProfile"
    ],
    [
        403,
        "CodingMethods"
    ],
    [
        404,
        "VersionYear"
    ],
    [
        405,
        "ModeNumber"
    ],
    [
        433,
        "Decode"
    ],
    [
        434,
        "DefaultImageColor"
    ],
    [
        435,
        "T82Options"
    ],
    [
        437,
        "JPEGTables"
    ],
    [
        512,
        "JPEGProc"
    ],
    [
        515,
        "JPEGRestartInterval"
    ],
    [
        517,
        "JPEGLosslessPredictors"
    ],
    [
        518,
        "JPEGPointTransforms"
    ],
    [
        519,
        "JPEGQTables"
    ],
    [
        520,
        "JPEGDCTables"
    ],
    [
        521,
        "JPEGACTables"
    ],
    [
        559,
        "StripRowCounts"
    ],
    [
        999,
        "USPTOMiscellaneous"
    ],
    [
        18247,
        "XP_DIP_XML"
    ],
    [
        18248,
        "StitchInfo"
    ],
    [
        28672,
        "SonyRawFileType"
    ],
    [
        28688,
        "SonyToneCurve"
    ],
    [
        28721,
        "VignettingCorrection"
    ],
    [
        28722,
        "VignettingCorrParams"
    ],
    [
        28724,
        "ChromaticAberrationCorrection"
    ],
    [
        28725,
        "ChromaticAberrationCorrParams"
    ],
    [
        28726,
        "DistortionCorrection"
    ],
    [
        28727,
        "DistortionCorrParams"
    ],
    [
        29895,
        "SonyCropTopLeft"
    ],
    [
        29896,
        "SonyCropSize"
    ],
    [
        32781,
        "ImageID"
    ],
    [
        32931,
        "WangTag1"
    ],
    [
        32932,
        "WangAnnotation"
    ],
    [
        32933,
        "WangTag3"
    ],
    [
        32934,
        "WangTag4"
    ],
    [
        32953,
        "ImageReferencePoints"
    ],
    [
        32954,
        "RegionXformTackPoint"
    ],
    [
        32955,
        "WarpQuadrilateral"
    ],
    [
        32956,
        "AffineTransformMat"
    ],
    [
        32995,
        "Matteing"
    ],
    [
        32996,
        "DataType"
    ],
    [
        32997,
        "ImageDepth"
    ],
    [
        32998,
        "TileDepth"
    ],
    [
        33300,
        "ImageFullWidth"
    ],
    [
        33301,
        "ImageFullHeight"
    ],
    [
        33302,
        "TextureFormat"
    ],
    [
        33303,
        "WrapModes"
    ],
    [
        33304,
        "FovCot"
    ],
    [
        33305,
        "MatrixWorldToScreen"
    ],
    [
        33306,
        "MatrixWorldToCamera"
    ],
    [
        33405,
        "Model2"
    ],
    [
        33421,
        "CFARepeatPatternDim"
    ],
    [
        33422,
        "CFAPattern2"
    ],
    [
        33423,
        "BatteryLevel"
    ],
    [
        33424,
        "KodakIFD"
    ],
    [
        33445,
        "MDFileTag"
    ],
    [
        33446,
        "MDScalePixel"
    ],
    [
        33447,
        "MDColorTable"
    ],
    [
        33448,
        "MDLabName"
    ],
    [
        33449,
        "MDSampleInfo"
    ],
    [
        33450,
        "MDPrepDate"
    ],
    [
        33451,
        "MDPrepTime"
    ],
    [
        33452,
        "MDFileUnits"
    ],
    [
        33589,
        "AdventScale"
    ],
    [
        33590,
        "AdventRevision"
    ],
    [
        33628,
        "UIC1Tag"
    ],
    [
        33629,
        "UIC2Tag"
    ],
    [
        33630,
        "UIC3Tag"
    ],
    [
        33631,
        "UIC4Tag"
    ],
    [
        33918,
        "IntergraphPacketData"
    ],
    [
        33919,
        "IntergraphFlagRegisters"
    ],
    [
        33921,
        "INGRReserved"
    ],
    [
        34016,
        "Site"
    ],
    [
        34017,
        "ColorSequence"
    ],
    [
        34018,
        "IT8Header"
    ],
    [
        34019,
        "RasterPadding"
    ],
    [
        34020,
        "BitsPerRunLength"
    ],
    [
        34021,
        "BitsPerExtendedRunLength"
    ],
    [
        34022,
        "ColorTable"
    ],
    [
        34023,
        "ImageColorIndicator"
    ],
    [
        34024,
        "BackgroundColorIndicator"
    ],
    [
        34025,
        "ImageColorValue"
    ],
    [
        34026,
        "BackgroundColorValue"
    ],
    [
        34027,
        "PixelIntensityRange"
    ],
    [
        34028,
        "TransparencyIndicator"
    ],
    [
        34029,
        "ColorCharacterization"
    ],
    [
        34030,
        "HCUsage"
    ],
    [
        34031,
        "TrapIndicator"
    ],
    [
        34032,
        "CMYKEquivalent"
    ],
    [
        34152,
        "AFCP_IPTC"
    ],
    [
        34232,
        "PixelMagicJBIGOptions"
    ],
    [
        34263,
        "JPLCartoIFD"
    ],
    [
        34306,
        "WB_GRGBLevels"
    ],
    [
        34310,
        "LeafData"
    ],
    [
        34687,
        "TIFF_FXExtensions"
    ],
    [
        34688,
        "MultiProfiles"
    ],
    [
        34689,
        "SharedData"
    ],
    [
        34690,
        "T88Options"
    ],
    [
        34732,
        "ImageLayer"
    ],
    [
        34750,
        "JBIGOptions"
    ],
    [
        34856,
        "Opto-ElectricConvFactor"
    ],
    [
        34857,
        "Interlace"
    ],
    [
        34908,
        "FaxRecvParams"
    ],
    [
        34909,
        "FaxSubAddress"
    ],
    [
        34910,
        "FaxRecvTime"
    ],
    [
        34929,
        "FedexEDR"
    ],
    [
        34954,
        "LeafSubIFD"
    ],
    [
        37387,
        "FlashEnergy"
    ],
    [
        37388,
        "SpatialFrequencyResponse"
    ],
    [
        37389,
        "Noise"
    ],
    [
        37390,
        "FocalPlaneXResolution"
    ],
    [
        37391,
        "FocalPlaneYResolution"
    ],
    [
        37392,
        "FocalPlaneResolutionUnit"
    ],
    [
        37397,
        "ExposureIndex"
    ],
    [
        37398,
        "TIFF-EPStandardID"
    ],
    [
        37399,
        "SensingMethod"
    ],
    [
        37434,
        "CIP3DataFile"
    ],
    [
        37435,
        "CIP3Sheet"
    ],
    [
        37436,
        "CIP3Side"
    ],
    [
        37439,
        "StoNits"
    ],
    [
        37679,
        "MSDocumentText"
    ],
    [
        37680,
        "MSPropertySetStorage"
    ],
    [
        37681,
        "MSDocumentTextPosition"
    ],
    [
        37724,
        "ImageSourceData"
    ],
    [
        40965,
        "InteropIFD"
    ],
    [
        40976,
        "SamsungRawPointersOffset"
    ],
    [
        40977,
        "SamsungRawPointersLength"
    ],
    [
        41217,
        "SamsungRawByteOrder"
    ],
    [
        41218,
        "SamsungRawUnknown"
    ],
    [
        41484,
        "SpatialFrequencyResponse"
    ],
    [
        41485,
        "Noise"
    ],
    [
        41489,
        "ImageNumber"
    ],
    [
        41490,
        "SecurityClassification"
    ],
    [
        41491,
        "ImageHistory"
    ],
    [
        41494,
        "TIFF-EPStandardID"
    ],
    [
        41995,
        "DeviceSettingDescription"
    ],
    [
        42112,
        "GDALMetadata"
    ],
    [
        42113,
        "GDALNoData"
    ],
    [
        44992,
        "ExpandSoftware"
    ],
    [
        44993,
        "ExpandLens"
    ],
    [
        44994,
        "ExpandFilm"
    ],
    [
        44995,
        "ExpandFilterLens"
    ],
    [
        44996,
        "ExpandScanner"
    ],
    [
        44997,
        "ExpandFlashLamp"
    ],
    [
        46275,
        "HasselbladRawImage"
    ],
    [
        48129,
        "PixelFormat"
    ],
    [
        48130,
        "Transformation"
    ],
    [
        48131,
        "Uncompressed"
    ],
    [
        48132,
        "ImageType"
    ],
    [
        48256,
        "ImageWidth"
    ],
    [
        48257,
        "ImageHeight"
    ],
    [
        48258,
        "WidthResolution"
    ],
    [
        48259,
        "HeightResolution"
    ],
    [
        48320,
        "ImageOffset"
    ],
    [
        48321,
        "ImageByteCount"
    ],
    [
        48322,
        "AlphaOffset"
    ],
    [
        48323,
        "AlphaByteCount"
    ],
    [
        48324,
        "ImageDataDiscard"
    ],
    [
        48325,
        "AlphaDataDiscard"
    ],
    [
        50215,
        "OceScanjobDesc"
    ],
    [
        50216,
        "OceApplicationSelector"
    ],
    [
        50217,
        "OceIDNumber"
    ],
    [
        50218,
        "OceImageLogic"
    ],
    [
        50255,
        "Annotations"
    ],
    [
        50459,
        "HasselbladExif"
    ],
    [
        50547,
        "OriginalFileName"
    ],
    [
        50560,
        "USPTOOriginalContentType"
    ],
    [
        50656,
        "CR2CFAPattern"
    ],
    [
        50710,
        "CFAPlaneColor"
    ],
    [
        50711,
        "CFALayout"
    ],
    [
        50712,
        "LinearizationTable"
    ],
    [
        50713,
        "BlackLevelRepeatDim"
    ],
    [
        50714,
        "BlackLevel"
    ],
    [
        50715,
        "BlackLevelDeltaH"
    ],
    [
        50716,
        "BlackLevelDeltaV"
    ],
    [
        50717,
        "WhiteLevel"
    ],
    [
        50718,
        "DefaultScale"
    ],
    [
        50719,
        "DefaultCropOrigin"
    ],
    [
        50720,
        "DefaultCropSize"
    ],
    [
        50733,
        "BayerGreenSplit"
    ],
    [
        50737,
        "ChromaBlurRadius"
    ],
    [
        50738,
        "AntiAliasStrength"
    ],
    [
        50752,
        "RawImageSegmentation"
    ],
    [
        50780,
        "BestQualityScale"
    ],
    [
        50784,
        "AliasLayerMetadata"
    ],
    [
        50829,
        "ActiveArea"
    ],
    [
        50830,
        "MaskedAreas"
    ],
    [
        50935,
        "NoiseReductionApplied"
    ],
    [
        50974,
        "SubTileBlockSize"
    ],
    [
        50975,
        "RowInterleaveFactor"
    ],
    [
        51008,
        "OpcodeList1"
    ],
    [
        51009,
        "OpcodeList2"
    ],
    [
        51022,
        "OpcodeList3"
    ],
    [
        51041,
        "NoiseProfile"
    ],
    [
        51114,
        "CacheVersion"
    ],
    [
        51125,
        "DefaultUserCrop"
    ],
    [
        51157,
        "NikonNEFInfo"
    ],
    [
        65024,
        "KdcIFD"
    ]
];
F(E, "ifd0", ct), F(E, "exif", ct), U(B, "gps", [
    [
        23,
        {
            M: "Magnetic North",
            T: "True North"
        }
    ],
    [
        25,
        {
            K: "Kilometers",
            M: "Miles",
            N: "Nautical Miles"
        }
    ]
]);
class ft extends re {
    static canHandle(e, t) {
        return 224 === e.getUint8(t + 1) && 1246120262 === e.getUint32(t + 4) && 0 === e.getUint8(t + 8);
    }
    parse() {
        return this.parseTags(), this.translate(), this.output;
    }
    parseTags() {
        this.raw = new Map([
            [
                0,
                this.chunk.getUint16(0)
            ],
            [
                2,
                this.chunk.getUint8(2)
            ],
            [
                3,
                this.chunk.getUint16(3)
            ],
            [
                5,
                this.chunk.getUint16(5)
            ],
            [
                7,
                this.chunk.getUint8(7)
            ],
            [
                8,
                this.chunk.getUint8(8)
            ]
        ]);
    }
}
c(ft, "type", "jfif"), c(ft, "headerLength", 9), T.set("jfif", ft), U(E, "jfif", [
    [
        0,
        "JFIFVersion"
    ],
    [
        2,
        "ResolutionUnit"
    ],
    [
        3,
        "XResolution"
    ],
    [
        5,
        "YResolution"
    ],
    [
        7,
        "ThumbnailWidth"
    ],
    [
        8,
        "ThumbnailHeight"
    ]
]);
class dt extends re {
    parse() {
        return this.parseTags(), this.translate(), this.output;
    }
    parseTags() {
        this.raw = new Map([
            [
                0,
                this.chunk.getUint32(0)
            ],
            [
                4,
                this.chunk.getUint32(4)
            ],
            [
                8,
                this.chunk.getUint8(8)
            ],
            [
                9,
                this.chunk.getUint8(9)
            ],
            [
                10,
                this.chunk.getUint8(10)
            ],
            [
                11,
                this.chunk.getUint8(11)
            ],
            [
                12,
                this.chunk.getUint8(12)
            ],
            ...Array.from(this.raw)
        ]);
    }
}
c(dt, "type", "ihdr"), T.set("ihdr", dt), U(E, "ihdr", [
    [
        0,
        "ImageWidth"
    ],
    [
        4,
        "ImageHeight"
    ],
    [
        8,
        "BitDepth"
    ],
    [
        9,
        "ColorType"
    ],
    [
        10,
        "Compression"
    ],
    [
        11,
        "Filter"
    ],
    [
        12,
        "Interlace"
    ]
]), U(B, "ihdr", [
    [
        9,
        {
            0: "Grayscale",
            2: "RGB",
            3: "Palette",
            4: "Grayscale with Alpha",
            6: "RGB with Alpha",
            DEFAULT: "Unknown"
        }
    ],
    [
        10,
        {
            0: "Deflate/Inflate",
            DEFAULT: "Unknown"
        }
    ],
    [
        11,
        {
            0: "Adaptive",
            DEFAULT: "Unknown"
        }
    ],
    [
        12,
        {
            0: "Noninterlaced",
            1: "Adam7 Interlace",
            DEFAULT: "Unknown"
        }
    ]
]);
class pt extends re {
    static canHandle(e, t) {
        return 226 === e.getUint8(t + 1) && 1229144927 === e.getUint32(t + 4);
    }
    static findPosition(e, t) {
        let i = super.findPosition(e, t);
        return i.chunkNumber = e.getUint8(t + 16), i.chunkCount = e.getUint8(t + 17), i.multiSegment = i.chunkCount > 1, i;
    }
    static handleMultiSegments(e) {
        return function(e) {
            let t = function(e) {
                let t = e[0].constructor, i = 0;
                for (let t of e)i += t.length;
                let n = new t(i), s = 0;
                for (let t of e)n.set(t, s), s += t.length;
                return n;
            }(e.map((e)=>e.chunk.toUint8()));
            return new I(t);
        }(e);
    }
    parse() {
        return this.raw = new Map, this.parseHeader(), this.parseTags(), this.translate(), this.output;
    }
    parseHeader() {
        let { raw: e } = this;
        this.chunk.byteLength < 84 && g("ICC header is too short");
        for (let [t, i] of Object.entries(gt)){
            t = parseInt(t, 10);
            let n = i(this.chunk, t);
            "\0\0\0\0" !== n && e.set(t, n);
        }
    }
    parseTags() {
        let e, t, i, n, s, { raw: r } = this, a = this.chunk.getUint32(128), o = 132, l = this.chunk.byteLength;
        for(; a--;){
            if (e = this.chunk.getString(o, 4), t = this.chunk.getUint32(o + 4), i = this.chunk.getUint32(o + 8), n = this.chunk.getString(t, 4), t + i > l) return void console.warn("reached the end of the first ICC chunk. Enable options.tiff.multiSegment to read all ICC segments.");
            s = this.parseTag(n, t, i), void 0 !== s && "\0\0\0\0" !== s && r.set(e, s), o += 12;
        }
    }
    parseTag(e, t, i) {
        switch(e){
            case "desc":
                return this.parseDesc(t);
            case "mluc":
                return this.parseMluc(t);
            case "text":
                return this.parseText(t, i);
            case "sig ":
                return this.parseSig(t);
        }
        if (!(t + i > this.chunk.byteLength)) return this.chunk.getUint8Array(t, i);
    }
    parseDesc(e) {
        let t = this.chunk.getUint32(e + 8) - 1;
        return m(this.chunk.getString(e + 12, t));
    }
    parseText(e, t) {
        return m(this.chunk.getString(e + 8, t - 8));
    }
    parseSig(e) {
        return m(this.chunk.getString(e + 8, 4));
    }
    parseMluc(e) {
        let { chunk: t } = this, i = t.getUint32(e + 8), n = t.getUint32(e + 12), s = e + 16, r = [];
        for(let a = 0; a < i; a++){
            let i = t.getString(s + 0, 2), a = t.getString(s + 2, 2), o = t.getUint32(s + 4), l = t.getUint32(s + 8) + e, h = m(t.getUnicodeString(l, o));
            r.push({
                lang: i,
                country: a,
                text: h
            }), s += n;
        }
        return 1 === i ? r[0].text : r;
    }
    translateValue(e, t) {
        return "string" == typeof e ? t[e] || t[e.toLowerCase()] || e : t[e] || e;
    }
}
c(pt, "type", "icc"), c(pt, "multiSegment", !0), c(pt, "headerLength", 18);
const gt = {
    4: mt,
    8: function(e, t) {
        return [
            e.getUint8(t),
            e.getUint8(t + 1) >> 4,
            e.getUint8(t + 1) % 16
        ].map((e)=>e.toString(10)).join(".");
    },
    12: mt,
    16: mt,
    20: mt,
    24: function(e, t) {
        const i = e.getUint16(t), n = e.getUint16(t + 2) - 1, s = e.getUint16(t + 4), r = e.getUint16(t + 6), a = e.getUint16(t + 8), o = e.getUint16(t + 10);
        return new Date(Date.UTC(i, n, s, r, a, o));
    },
    36: mt,
    40: mt,
    48: mt,
    52: mt,
    64: (e, t)=>e.getUint32(t),
    80: mt
};
function mt(e, t) {
    return m(e.getString(t, 4));
}
T.set("icc", pt), U(E, "icc", [
    [
        4,
        "ProfileCMMType"
    ],
    [
        8,
        "ProfileVersion"
    ],
    [
        12,
        "ProfileClass"
    ],
    [
        16,
        "ColorSpaceData"
    ],
    [
        20,
        "ProfileConnectionSpace"
    ],
    [
        24,
        "ProfileDateTime"
    ],
    [
        36,
        "ProfileFileSignature"
    ],
    [
        40,
        "PrimaryPlatform"
    ],
    [
        44,
        "CMMFlags"
    ],
    [
        48,
        "DeviceManufacturer"
    ],
    [
        52,
        "DeviceModel"
    ],
    [
        56,
        "DeviceAttributes"
    ],
    [
        64,
        "RenderingIntent"
    ],
    [
        68,
        "ConnectionSpaceIlluminant"
    ],
    [
        80,
        "ProfileCreator"
    ],
    [
        84,
        "ProfileID"
    ],
    [
        "Header",
        "ProfileHeader"
    ],
    [
        "MS00",
        "WCSProfiles"
    ],
    [
        "bTRC",
        "BlueTRC"
    ],
    [
        "bXYZ",
        "BlueMatrixColumn"
    ],
    [
        "bfd",
        "UCRBG"
    ],
    [
        "bkpt",
        "MediaBlackPoint"
    ],
    [
        "calt",
        "CalibrationDateTime"
    ],
    [
        "chad",
        "ChromaticAdaptation"
    ],
    [
        "chrm",
        "Chromaticity"
    ],
    [
        "ciis",
        "ColorimetricIntentImageState"
    ],
    [
        "clot",
        "ColorantTableOut"
    ],
    [
        "clro",
        "ColorantOrder"
    ],
    [
        "clrt",
        "ColorantTable"
    ],
    [
        "cprt",
        "ProfileCopyright"
    ],
    [
        "crdi",
        "CRDInfo"
    ],
    [
        "desc",
        "ProfileDescription"
    ],
    [
        "devs",
        "DeviceSettings"
    ],
    [
        "dmdd",
        "DeviceModelDesc"
    ],
    [
        "dmnd",
        "DeviceMfgDesc"
    ],
    [
        "dscm",
        "ProfileDescriptionML"
    ],
    [
        "fpce",
        "FocalPlaneColorimetryEstimates"
    ],
    [
        "gTRC",
        "GreenTRC"
    ],
    [
        "gXYZ",
        "GreenMatrixColumn"
    ],
    [
        "gamt",
        "Gamut"
    ],
    [
        "kTRC",
        "GrayTRC"
    ],
    [
        "lumi",
        "Luminance"
    ],
    [
        "meas",
        "Measurement"
    ],
    [
        "meta",
        "Metadata"
    ],
    [
        "mmod",
        "MakeAndModel"
    ],
    [
        "ncl2",
        "NamedColor2"
    ],
    [
        "ncol",
        "NamedColor"
    ],
    [
        "ndin",
        "NativeDisplayInfo"
    ],
    [
        "pre0",
        "Preview0"
    ],
    [
        "pre1",
        "Preview1"
    ],
    [
        "pre2",
        "Preview2"
    ],
    [
        "ps2i",
        "PS2RenderingIntent"
    ],
    [
        "ps2s",
        "PostScript2CSA"
    ],
    [
        "psd0",
        "PostScript2CRD0"
    ],
    [
        "psd1",
        "PostScript2CRD1"
    ],
    [
        "psd2",
        "PostScript2CRD2"
    ],
    [
        "psd3",
        "PostScript2CRD3"
    ],
    [
        "pseq",
        "ProfileSequenceDesc"
    ],
    [
        "psid",
        "ProfileSequenceIdentifier"
    ],
    [
        "psvm",
        "PS2CRDVMSize"
    ],
    [
        "rTRC",
        "RedTRC"
    ],
    [
        "rXYZ",
        "RedMatrixColumn"
    ],
    [
        "resp",
        "OutputResponse"
    ],
    [
        "rhoc",
        "ReflectionHardcopyOrigColorimetry"
    ],
    [
        "rig0",
        "PerceptualRenderingIntentGamut"
    ],
    [
        "rig2",
        "SaturationRenderingIntentGamut"
    ],
    [
        "rpoc",
        "ReflectionPrintOutputColorimetry"
    ],
    [
        "sape",
        "SceneAppearanceEstimates"
    ],
    [
        "scoe",
        "SceneColorimetryEstimates"
    ],
    [
        "scrd",
        "ScreeningDesc"
    ],
    [
        "scrn",
        "Screening"
    ],
    [
        "targ",
        "CharTarget"
    ],
    [
        "tech",
        "Technology"
    ],
    [
        "vcgt",
        "VideoCardGamma"
    ],
    [
        "view",
        "ViewingConditions"
    ],
    [
        "vued",
        "ViewingCondDesc"
    ],
    [
        "wtpt",
        "MediaWhitePoint"
    ]
]);
const St = {
    "4d2p": "Erdt Systems",
    AAMA: "Aamazing Technologies",
    ACER: "Acer",
    ACLT: "Acolyte Color Research",
    ACTI: "Actix Sytems",
    ADAR: "Adara Technology",
    ADBE: "Adobe",
    ADI: "ADI Systems",
    AGFA: "Agfa Graphics",
    ALMD: "Alps Electric",
    ALPS: "Alps Electric",
    ALWN: "Alwan Color Expertise",
    AMTI: "Amiable Technologies",
    AOC: "AOC International",
    APAG: "Apago",
    APPL: "Apple Computer",
    AST: "AST",
    "AT&T": "AT&T",
    BAEL: "BARBIERI electronic",
    BRCO: "Barco NV",
    BRKP: "Breakpoint",
    BROT: "Brother",
    BULL: "Bull",
    BUS: "Bus Computer Systems",
    "C-IT": "C-Itoh",
    CAMR: "Intel",
    CANO: "Canon",
    CARR: "Carroll Touch",
    CASI: "Casio",
    CBUS: "Colorbus PL",
    CEL: "Crossfield",
    CELx: "Crossfield",
    CGS: "CGS Publishing Technologies International",
    CHM: "Rochester Robotics",
    CIGL: "Colour Imaging Group, London",
    CITI: "Citizen",
    CL00: "Candela",
    CLIQ: "Color IQ",
    CMCO: "Chromaco",
    CMiX: "CHROMiX",
    COLO: "Colorgraphic Communications",
    COMP: "Compaq",
    COMp: "Compeq/Focus Technology",
    CONR: "Conrac Display Products",
    CORD: "Cordata Technologies",
    CPQ: "Compaq",
    CPRO: "ColorPro",
    CRN: "Cornerstone",
    CTX: "CTX International",
    CVIS: "ColorVision",
    CWC: "Fujitsu Laboratories",
    DARI: "Darius Technology",
    DATA: "Dataproducts",
    DCP: "Dry Creek Photo",
    DCRC: "Digital Contents Resource Center, Chung-Ang University",
    DELL: "Dell Computer",
    DIC: "Dainippon Ink and Chemicals",
    DICO: "Diconix",
    DIGI: "Digital",
    "DL&C": "Digital Light & Color",
    DPLG: "Doppelganger",
    DS: "Dainippon Screen",
    DSOL: "DOOSOL",
    DUPN: "DuPont",
    EPSO: "Epson",
    ESKO: "Esko-Graphics",
    ETRI: "Electronics and Telecommunications Research Institute",
    EVER: "Everex Systems",
    EXAC: "ExactCODE",
    Eizo: "Eizo",
    FALC: "Falco Data Products",
    FF: "Fuji Photo Film",
    FFEI: "FujiFilm Electronic Imaging",
    FNRD: "Fnord Software",
    FORA: "Fora",
    FORE: "Forefront Technology",
    FP: "Fujitsu",
    FPA: "WayTech Development",
    FUJI: "Fujitsu",
    FX: "Fuji Xerox",
    GCC: "GCC Technologies",
    GGSL: "Global Graphics Software",
    GMB: "Gretagmacbeth",
    GMG: "GMG",
    GOLD: "GoldStar Technology",
    GOOG: "Google",
    GPRT: "Giantprint",
    GTMB: "Gretagmacbeth",
    GVC: "WayTech Development",
    GW2K: "Sony",
    HCI: "HCI",
    HDM: "Heidelberger Druckmaschinen",
    HERM: "Hermes",
    HITA: "Hitachi America",
    HP: "Hewlett-Packard",
    HTC: "Hitachi",
    HiTi: "HiTi Digital",
    IBM: "IBM",
    IDNT: "Scitex",
    IEC: "Hewlett-Packard",
    IIYA: "Iiyama North America",
    IKEG: "Ikegami Electronics",
    IMAG: "Image Systems",
    IMI: "Ingram Micro",
    INTC: "Intel",
    INTL: "N/A (INTL)",
    INTR: "Intra Electronics",
    IOCO: "Iocomm International Technology",
    IPS: "InfoPrint Solutions Company",
    IRIS: "Scitex",
    ISL: "Ichikawa Soft Laboratory",
    ITNL: "N/A (ITNL)",
    IVM: "IVM",
    IWAT: "Iwatsu Electric",
    Idnt: "Scitex",
    Inca: "Inca Digital Printers",
    Iris: "Scitex",
    JPEG: "Joint Photographic Experts Group",
    JSFT: "Jetsoft Development",
    JVC: "JVC Information Products",
    KART: "Scitex",
    KFC: "KFC Computek Components",
    KLH: "KLH Computers",
    KMHD: "Konica Minolta",
    KNCA: "Konica",
    KODA: "Kodak",
    KYOC: "Kyocera",
    Kart: "Scitex",
    LCAG: "Leica",
    LCCD: "Leeds Colour",
    LDAK: "Left Dakota",
    LEAD: "Leading Technology",
    LEXM: "Lexmark International",
    LINK: "Link Computer",
    LINO: "Linotronic",
    LITE: "Lite-On",
    Leaf: "Leaf",
    Lino: "Linotronic",
    MAGC: "Mag Computronic",
    MAGI: "MAG Innovision",
    MANN: "Mannesmann",
    MICN: "Micron Technology",
    MICR: "Microtek",
    MICV: "Microvitec",
    MINO: "Minolta",
    MITS: "Mitsubishi Electronics America",
    MITs: "Mitsuba",
    MNLT: "Minolta",
    MODG: "Modgraph",
    MONI: "Monitronix",
    MONS: "Monaco Systems",
    MORS: "Morse Technology",
    MOTI: "Motive Systems",
    MSFT: "Microsoft",
    MUTO: "MUTOH INDUSTRIES",
    Mits: "Mitsubishi Electric",
    NANA: "NANAO",
    NEC: "NEC",
    NEXP: "NexPress Solutions",
    NISS: "Nissei Sangyo America",
    NKON: "Nikon",
    NONE: "none",
    OCE: "Oce Technologies",
    OCEC: "OceColor",
    OKI: "Oki",
    OKID: "Okidata",
    OKIP: "Okidata",
    OLIV: "Olivetti",
    OLYM: "Olympus",
    ONYX: "Onyx Graphics",
    OPTI: "Optiquest",
    PACK: "Packard Bell",
    PANA: "Matsushita Electric Industrial",
    PANT: "Pantone",
    PBN: "Packard Bell",
    PFU: "PFU",
    PHIL: "Philips Consumer Electronics",
    PNTX: "HOYA",
    POne: "Phase One A/S",
    PREM: "Premier Computer Innovations",
    PRIN: "Princeton Graphic Systems",
    PRIP: "Princeton Publishing Labs",
    QLUX: "Hong Kong",
    QMS: "QMS",
    QPCD: "QPcard AB",
    QUAD: "QuadLaser",
    QUME: "Qume",
    RADI: "Radius",
    RDDx: "Integrated Color Solutions",
    RDG: "Roland DG",
    REDM: "REDMS Group",
    RELI: "Relisys",
    RGMS: "Rolf Gierling Multitools",
    RICO: "Ricoh",
    RNLD: "Edmund Ronald",
    ROYA: "Royal",
    RPC: "Ricoh Printing Systems",
    RTL: "Royal Information Electronics",
    SAMP: "Sampo",
    SAMS: "Samsung",
    SANT: "Jaime Santana Pomares",
    SCIT: "Scitex",
    SCRN: "Dainippon Screen",
    SDP: "Scitex",
    SEC: "Samsung",
    SEIK: "Seiko Instruments",
    SEIk: "Seikosha",
    SGUY: "ScanGuy.com",
    SHAR: "Sharp Laboratories",
    SICC: "International Color Consortium",
    SONY: "Sony",
    SPCL: "SpectraCal",
    STAR: "Star",
    STC: "Sampo Technology",
    Scit: "Scitex",
    Sdp: "Scitex",
    Sony: "Sony",
    TALO: "Talon Technology",
    TAND: "Tandy",
    TATU: "Tatung",
    TAXA: "TAXAN America",
    TDS: "Tokyo Denshi Sekei",
    TECO: "TECO Information Systems",
    TEGR: "Tegra",
    TEKT: "Tektronix",
    TI: "Texas Instruments",
    TMKR: "TypeMaker",
    TOSB: "Toshiba",
    TOSH: "Toshiba",
    TOTK: "TOTOKU ELECTRIC",
    TRIU: "Triumph",
    TSBT: "Toshiba",
    TTX: "TTX Computer Products",
    TVM: "TVM Professional Monitor",
    TW: "TW Casper",
    ULSX: "Ulead Systems",
    UNIS: "Unisys",
    UTZF: "Utz Fehlau & Sohn",
    VARI: "Varityper",
    VIEW: "Viewsonic",
    VISL: "Visual communication",
    VIVO: "Vivo Mobile Communication",
    WANG: "Wang",
    WLBR: "Wilbur Imaging",
    WTG2: "Ware To Go",
    WYSE: "WYSE Technology",
    XERX: "Xerox",
    XRIT: "X-Rite",
    ZRAN: "Zoran",
    Zebr: "Zebra Technologies",
    appl: "Apple Computer",
    bICC: "basICColor",
    berg: "bergdesign",
    ceyd: "Integrated Color Solutions",
    clsp: "MacDermid ColorSpan",
    ds: "Dainippon Screen",
    dupn: "DuPont",
    ffei: "FujiFilm Electronic Imaging",
    flux: "FluxData",
    iris: "Scitex",
    kart: "Scitex",
    lcms: "Little CMS",
    lino: "Linotronic",
    none: "none",
    ob4d: "Erdt Systems",
    obic: "Medigraph",
    quby: "Qubyx Sarl",
    scit: "Scitex",
    scrn: "Dainippon Screen",
    sdp: "Scitex",
    siwi: "SIWI GRAFIKA",
    yxym: "YxyMaster"
}, Ct = {
    scnr: "Scanner",
    mntr: "Monitor",
    prtr: "Printer",
    link: "Device Link",
    abst: "Abstract",
    spac: "Color Space Conversion Profile",
    nmcl: "Named Color",
    cenc: "ColorEncodingSpace profile",
    mid: "MultiplexIdentification profile",
    mlnk: "MultiplexLink profile",
    mvis: "MultiplexVisualization profile",
    nkpf: "Nikon Input Device Profile (NON-STANDARD!)"
};
U(B, "icc", [
    [
        4,
        St
    ],
    [
        12,
        Ct
    ],
    [
        40,
        Object.assign({}, St, Ct)
    ],
    [
        48,
        St
    ],
    [
        80,
        St
    ],
    [
        64,
        {
            0: "Perceptual",
            1: "Relative Colorimetric",
            2: "Saturation",
            3: "Absolute Colorimetric"
        }
    ],
    [
        "tech",
        {
            amd: "Active Matrix Display",
            crt: "Cathode Ray Tube Display",
            kpcd: "Photo CD",
            pmd: "Passive Matrix Display",
            dcam: "Digital Camera",
            dcpj: "Digital Cinema Projector",
            dmpc: "Digital Motion Picture Camera",
            dsub: "Dye Sublimation Printer",
            epho: "Electrophotographic Printer",
            esta: "Electrostatic Printer",
            flex: "Flexography",
            fprn: "Film Writer",
            fscn: "Film Scanner",
            grav: "Gravure",
            ijet: "Ink Jet Printer",
            imgs: "Photo Image Setter",
            mpfr: "Motion Picture Film Recorder",
            mpfs: "Motion Picture Film Scanner",
            offs: "Offset Lithography",
            pjtv: "Projection Television",
            rpho: "Photographic Paper Printer",
            rscn: "Reflective Scanner",
            silk: "Silkscreen",
            twax: "Thermal Wax Printer",
            vidc: "Video Camera",
            vidm: "Video Monitor"
        }
    ]
]);
class yt extends re {
    static canHandle(e, t, i) {
        return 237 === e.getUint8(t + 1) && "Photoshop" === e.getString(t + 4, 9) && void 0 !== this.containsIptc8bim(e, t, i);
    }
    static headerLength(e, t, i) {
        let n, s = this.containsIptc8bim(e, t, i);
        if (void 0 !== s) return n = e.getUint8(t + s + 7), n % 2 != 0 && (n += 1), 0 === n && (n = 4), s + 8 + n;
    }
    static containsIptc8bim(e, t, i) {
        for(let n = 0; n < i; n++)if (this.isIptcSegmentHead(e, t + n)) return n;
    }
    static isIptcSegmentHead(e, t) {
        return 56 === e.getUint8(t) && 943868237 === e.getUint32(t) && 1028 === e.getUint16(t + 4);
    }
    parse() {
        let { raw: e } = this, t = this.chunk.byteLength - 1, i = !1;
        for(let n = 0; n < t; n++)if (28 === this.chunk.getUint8(n) && 2 === this.chunk.getUint8(n + 1)) {
            i = !0;
            let t = this.chunk.getUint16(n + 3), s = this.chunk.getUint8(n + 2), r = this.chunk.getLatin1String(n + 5, t);
            e.set(s, this.pluralizeValue(e.get(s), r)), n += 4 + t;
        } else if (i) break;
        return this.translate(), this.output;
    }
    pluralizeValue(e, t) {
        return void 0 !== e ? e instanceof Array ? (e.push(t), e) : [
            e,
            t
        ] : t;
    }
}
c(yt, "type", "iptc"), c(yt, "translateValues", !1), c(yt, "reviveValues", !1), T.set("iptc", yt), U(E, "iptc", [
    [
        0,
        "ApplicationRecordVersion"
    ],
    [
        3,
        "ObjectTypeReference"
    ],
    [
        4,
        "ObjectAttributeReference"
    ],
    [
        5,
        "ObjectName"
    ],
    [
        7,
        "EditStatus"
    ],
    [
        8,
        "EditorialUpdate"
    ],
    [
        10,
        "Urgency"
    ],
    [
        12,
        "SubjectReference"
    ],
    [
        15,
        "Category"
    ],
    [
        20,
        "SupplementalCategories"
    ],
    [
        22,
        "FixtureIdentifier"
    ],
    [
        25,
        "Keywords"
    ],
    [
        26,
        "ContentLocationCode"
    ],
    [
        27,
        "ContentLocationName"
    ],
    [
        30,
        "ReleaseDate"
    ],
    [
        35,
        "ReleaseTime"
    ],
    [
        37,
        "ExpirationDate"
    ],
    [
        38,
        "ExpirationTime"
    ],
    [
        40,
        "SpecialInstructions"
    ],
    [
        42,
        "ActionAdvised"
    ],
    [
        45,
        "ReferenceService"
    ],
    [
        47,
        "ReferenceDate"
    ],
    [
        50,
        "ReferenceNumber"
    ],
    [
        55,
        "DateCreated"
    ],
    [
        60,
        "TimeCreated"
    ],
    [
        62,
        "DigitalCreationDate"
    ],
    [
        63,
        "DigitalCreationTime"
    ],
    [
        65,
        "OriginatingProgram"
    ],
    [
        70,
        "ProgramVersion"
    ],
    [
        75,
        "ObjectCycle"
    ],
    [
        80,
        "Byline"
    ],
    [
        85,
        "BylineTitle"
    ],
    [
        90,
        "City"
    ],
    [
        92,
        "Sublocation"
    ],
    [
        95,
        "State"
    ],
    [
        100,
        "CountryCode"
    ],
    [
        101,
        "Country"
    ],
    [
        103,
        "OriginalTransmissionReference"
    ],
    [
        105,
        "Headline"
    ],
    [
        110,
        "Credit"
    ],
    [
        115,
        "Source"
    ],
    [
        116,
        "CopyrightNotice"
    ],
    [
        118,
        "Contact"
    ],
    [
        120,
        "Caption"
    ],
    [
        121,
        "LocalCaption"
    ],
    [
        122,
        "Writer"
    ],
    [
        125,
        "RasterizedCaption"
    ],
    [
        130,
        "ImageType"
    ],
    [
        131,
        "ImageOrientation"
    ],
    [
        135,
        "LanguageIdentifier"
    ],
    [
        150,
        "AudioType"
    ],
    [
        151,
        "AudioSamplingRate"
    ],
    [
        152,
        "AudioSamplingResolution"
    ],
    [
        153,
        "AudioDuration"
    ],
    [
        154,
        "AudioOutcue"
    ],
    [
        184,
        "JobID"
    ],
    [
        185,
        "MasterDocumentID"
    ],
    [
        186,
        "ShortDocumentID"
    ],
    [
        187,
        "UniqueDocumentID"
    ],
    [
        188,
        "OwnerID"
    ],
    [
        200,
        "ObjectPreviewFileFormat"
    ],
    [
        201,
        "ObjectPreviewFileVersion"
    ],
    [
        202,
        "ObjectPreviewData"
    ],
    [
        221,
        "Prefs"
    ],
    [
        225,
        "ClassifyState"
    ],
    [
        228,
        "SimilarityIndex"
    ],
    [
        230,
        "DocumentNotes"
    ],
    [
        231,
        "DocumentHistory"
    ],
    [
        232,
        "ExifCameraInfo"
    ],
    [
        255,
        "CatalogSets"
    ]
]), U(B, "iptc", [
    [
        10,
        {
            0: "0 (reserved)",
            1: "1 (most urgent)",
            2: "2",
            3: "3",
            4: "4",
            5: "5 (normal urgency)",
            6: "6",
            7: "7",
            8: "8 (least urgent)",
            9: "9 (user-defined priority)"
        }
    ],
    [
        75,
        {
            a: "Morning",
            b: "Both Morning and Evening",
            p: "Evening"
        }
    ],
    [
        131,
        {
            L: "Landscape",
            P: "Portrait",
            S: "Square"
        }
    ]
]);
const __TURBOPACK__default__export__ = tt;
;
}),
];

//# sourceMappingURL=node_modules_f1210d02._.js.map